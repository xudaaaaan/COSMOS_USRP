<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: uhd::stream_args_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.15.0.main-0-ee6805b3</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structuhd_1_1stream__args__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structuhd_1_1stream__args__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uhd::stream_args_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="stream_8hpp_source.html">uhd/stream.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa54b7dc3e2c71d11c774d8b4a15984cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1stream__args__t.html#aa54b7dc3e2c71d11c774d8b4a15984cc">stream_args_t</a> (const std::string &amp;cpu=&quot;&quot;, const std::string &amp;otw=&quot;&quot;)</td></tr>
<tr class="memdesc:aa54b7dc3e2c71d11c774d8b4a15984cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience constructor for streamer args.  <a href="#aa54b7dc3e2c71d11c774d8b4a15984cc">More...</a><br /></td></tr>
<tr class="separator:aa54b7dc3e2c71d11c774d8b4a15984cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a602a64b4937a85dba84e7f724387e252"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1stream__args__t.html#a602a64b4937a85dba84e7f724387e252">cpu_format</a></td></tr>
<tr class="separator:a602a64b4937a85dba84e7f724387e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba0e946d2f83f7ac085f4f4e2ce9578"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1stream__args__t.html#a0ba0e946d2f83f7ac085f4f4e2ce9578">otw_format</a></td></tr>
<tr class="separator:a0ba0e946d2f83f7ac085f4f4e2ce9578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4463f2eec2cc7ee70f84baacbb26e1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1stream__args__t.html#a4463f2eec2cc7ee70f84baacbb26e1ef">args</a></td></tr>
<tr class="separator:a4463f2eec2cc7ee70f84baacbb26e1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfb903c0cb6c040d78ef90917e55a61"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1stream__args__t.html#aebfb903c0cb6c040d78ef90917e55a61">channels</a></td></tr>
<tr class="separator:aebfb903c0cb6c040d78ef90917e55a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct of parameters to construct a streamer.</p>
<p>Here is an example of how a stream args object could be used in conjunction with <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Create the stream args object and initialize the data formats to fc32 and sc16:</span></div><div class="line"><a class="code" href="structuhd_1_1stream__args__t.html">uhd::stream_args_t</a> stream_args(<span class="stringliteral">&quot;fc32&quot;</span>, <span class="stringliteral">&quot;sc16&quot;</span>);</div><div class="line"><span class="comment">// 2. Set the channel list, we want 3 streamers coming from channels</span></div><div class="line"><span class="comment">//    0, 1 and 2, in that order:</span></div><div class="line">stream_args.channels = {0, 1, 2};</div><div class="line"><span class="comment">// 3. Set optional args:</span></div><div class="line">stream_args.args[<span class="stringliteral">&quot;spp&quot;</span>] = <span class="stringliteral">&quot;200&quot;</span>; <span class="comment">// 200 samples per packet</span></div><div class="line"><span class="comment">// Now use these args to create an rx streamer:</span></div><div class="line"><span class="comment">// (We assume that usrp is a valid uhd::usrp::multi_usrp)</span></div><div class="line"><a class="code" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">uhd::rx_streamer::sptr</a> rx_stream = usrp-&gt;get_rx_stream(stream_args);</div><div class="line"><span class="comment">// Now, any calls to rx_stream must provide a vector of 3 buffers,</span></div><div class="line"><span class="comment">// one per channel.</span></div></div><!-- fragment --><p><b>Note:</b> Not all combinations of CPU and OTW format have conversion support. You may however write and register your own conversion routines.</p>
<p>If you are creating stream args to connect to an RFNoC block, then you might want to specify block ID and port, too: </p><div class="fragment"><div class="line">stream_args.args[<span class="stringliteral">&quot;block_id0&quot;</span>] = <span class="stringliteral">&quot;0/Radio_0&quot;</span>;</div><div class="line">stream_args.args[<span class="stringliteral">&quot;block_id1&quot;</span>] = <span class="stringliteral">&quot;0/Radio_1&quot;</span>;</div><div class="line">stream_args.args[<span class="stringliteral">&quot;block_id2&quot;</span>] = <span class="stringliteral">&quot;0/Radio_1&quot;</span>; <span class="comment">// Chan 1 and 2 go to the same radio</span></div><div class="line">stream_args.args[<span class="stringliteral">&quot;block_port0&quot;</span>] = <span class="stringliteral">&quot;0&quot;</span>;</div><div class="line">stream_args.args[<span class="stringliteral">&quot;block_port1&quot;</span>] = <span class="stringliteral">&quot;0&quot;</span>;</div><div class="line">stream_args.args[<span class="stringliteral">&quot;block_port2&quot;</span>] = <span class="stringliteral">&quot;1&quot;</span>;</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa54b7dc3e2c71d11c774d8b4a15984cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54b7dc3e2c71d11c774d8b4a15984cc">&#9670;&nbsp;</a></span>stream_args_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uhd::stream_args_t::stream_args_t </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cpu</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>otw</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience constructor for streamer args. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4463f2eec2cc7ee70f84baacbb26e1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4463f2eec2cc7ee70f84baacbb26e1ef">&#9670;&nbsp;</a></span>args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> uhd::stream_args_t::args</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The args parameter is used to pass arbitrary key/value pairs. Possible keys used by args (depends on implementation):</p>
<ul>
<li>fullscale: specifies the full-scale amplitude when using floats. By default, the fullscale amplitude under floating point is 1.0. Set the "fullscale" to scale the samples in the host to the expected input range and/or output range of your application.</li>
<li>peak: specifies a fractional sample level to calculate scaling with the sc8 wire format. When using sc8 samples over the wire, the device must scale samples (both on the host and in the device) to satisfy the dynamic range needs. The peak value specifies a fraction of the maximum sample level (1.0 = 100%). Set peak to max_sample_level/full_scale_level to ensure optimum dynamic range.</li>
<li>underflow_policy: how the TX DSP should recover from underflow. Possible options are "next_burst" or "next_packet". In the "next_burst" mode, the DSP drops incoming packets until a new burst is started. In the "next_packet" mode, the DSP starts transmitting again at the next packet.</li>
<li>spp: (samples per packet) controls the size of RX packets. When not specified, the packets are always maximum frame size. Users should specify this option to request smaller than default packets, probably with the intention of reducing packet latency.</li>
<li>noclear: Used by tx_dsp_core_200 and rx_dsp_core_200</li>
</ul>
<p>The following are not implemented, but are listed for conceptual purposes:</p><ul>
<li>function: magnitude or phase/magnitude</li>
<li>units: numeric units like counts or dBm</li>
</ul>
<p>Other options are device-specific:</p><ul>
<li>port, addr: Alternative receiver streamer destination. </li>
</ul>

</div>
</div>
<a id="aebfb903c0cb6c040d78ef90917e55a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfb903c0cb6c040d78ef90917e55a61">&#9670;&nbsp;</a></span>channels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; uhd::stream_args_t::channels</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The channels is a list of channel numbers. Leave this blank to default to channel 0 (single-channel application). Set channels for a multi-channel application. Channel mapping depends on the front-end selection (see also <a class="el" href="page_configuration.html#config_subdev">Specifying the Subdevice</a>).</p>
<p>A very simple example is an X300 with two daughterboards and a subdev spec of <code>A:0 B:0</code>. This means the device has two channels available.</p>
<p>Setting <code>stream_args.channels = (0, 1)</code> therefore configures MIMO streaming from both channels. By switching the channel indexes, <code>stream_args.channels = (1, 0)</code>, the channels are switched and the first channel of the USRP is mapped to the second channel in the application.</p>
<p>If only a single channel is used for streaming, <code>stream_args.channels = (1,)</code> would only select a single channel (in this case, the second one). When streaming a single channel from the B-side radio of a USRP, this is a more versatile solution than setting the subdev globally to "B:0". </p>

</div>
</div>
<a id="a602a64b4937a85dba84e7f724387e252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602a64b4937a85dba84e7f724387e252">&#9670;&nbsp;</a></span>cpu_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string uhd::stream_args_t::cpu_format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The CPU format is a string that describes the format of host memory. Conversions for the following CPU formats have been implemented:</p><ul>
<li>fc64 - complex&lt;double&gt;</li>
<li>fc32 - complex&lt;float&gt;</li>
<li>sc16 - complex&lt;int16_t&gt;</li>
<li>sc8 - complex&lt;int8_t&gt;</li>
</ul>
<p>The following are not implemented, but are listed to demonstrate naming convention:</p><ul>
<li>f32 - float</li>
<li>f64 - double</li>
<li>s16 - int16_t</li>
<li>s8 - int8_t</li>
</ul>
<p>The CPU format can be chosen depending on what the application requires. </p>

</div>
</div>
<a id="a0ba0e946d2f83f7ac085f4f4e2ce9578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba0e946d2f83f7ac085f4f4e2ce9578">&#9670;&nbsp;</a></span>otw_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string uhd::stream_args_t::otw_format</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The OTW format is a string that describes the format over-the-wire. The following over-the-wire formats have been implemented:</p><ul>
<li>sc16 - Q16 I16</li>
<li>sc8 - Q8_1 I8_1 Q8_0 I8_0</li>
<li>sc12 (Only some devices)</li>
</ul>
<p>The following are not implemented, but are listed to demonstrate naming convention:</p><ul>
<li>s16 - R16_1 R16_0</li>
<li>s8 - R8_3 R8_2 R8_1 R8_0</li>
</ul>
<p>Setting the OTW ("over-the-wire") format is, in theory, transparent to the application, but changing this can have some side effects. Using less bits for example (e.g. when going from <code>otw_format</code> <code>sc16</code> to <code>sc8</code>) will reduce the dynamic range, and increases quantization noise. On the other hand, it reduces the load on the data link and thus allows more bandwidth (a USRP N210 can work with 25 MHz bandwidth for 16-Bit complex samples, and 50 MHz for 8-Bit complex samples). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/uhd/<a class="el" href="stream_8hpp_source.html">stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceuhd.html">uhd</a></li><li class="navelem"><a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
