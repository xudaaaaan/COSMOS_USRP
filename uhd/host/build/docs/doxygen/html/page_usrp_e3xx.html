<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: USRP E3xx Series</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.15.0.main-0-ee6805b3</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_usrp_e3xx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">USRP E3xx Series </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#e3xx_feature_list">Comparative features list</a><ul><li class="level2"><a href="#e3xx_feature_list_e310">E310</a></li>
<li class="level2"><a href="#e3xx_feature_list_e320">E320</a></li>
</ul>
</li>
<li class="level1"><a href="#e310_overview">E310 Overview</a><ul><li class="level2"><a href="#e310_zynq">The Zynq CPU/FPGA and host operating system</a></li>
<li class="level2"><a href="#e31x_migration">E310 Migration Guide to MPM architecture</a></li>
</ul>
</li>
<li class="level1"><a href="#e320_overview">E320 Overview</a><ul><li class="level2"><a href="#e320_zynq">The Zynq CPU/FPGA and host operating system</a></li>
<li class="level2"><a href="#e320_micro">The STM32 microcontroller</a></li>
<li class="level2"><a href="#e3xx_sdcard">The SD card</a></li>
</ul>
</li>
<li class="level1"><a href="#e3xx_getting_started">Getting started</a><ul><li class="level2"><a href="#e3xx_getting_started_assembling">Assembling the E3XX</a></li>
<li class="level2"><a href="#e3xx_getting_started_fs_update">Updating the file system</a><ul><li class="level3"><a href="#e31x_fs">E310/E312/E313 file system</a></li>
<li class="level3"><a href="#e320_fs">E320 file system</a></li>
<li class="level3"><a href="#update_sdcard">Updating the SD card</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#e3xx_fsbuild">Building custom filesystems and SD card images</a><ul><li class="level2"><a href="#e3xx_fsbuild_docker">Using Docker to build filesystems</a></li>
<li class="level2"><a href="#e3xx_getting_started_serial">Serial connection</a><ul><li class="level3"><a href="#e320_getting_started_serial_micro">Connecting to the microcontroller</a></li>
</ul>
</li>
<li class="level2"><a href="#e3xx_getting_started_ssh">SSH connection</a></li>
<li class="level2"><a href="#e3xx_getting_started_connectivity">Network Connectivity</a></li>
<li class="level2"><a href="#e3xx_getting_started_security">Security-related settings</a></li>
<li class="level2"><a href="#e3xx_getting_started_fpga_update">Updating the FPGA</a></li>
</ul>
</li>
<li class="level1"><a href="#e3xx_usage">Using an E3XX USRP from UHD</a><ul><li class="level2"><a href="#e3xx_usage_device_args">Device arguments</a></li>
<li class="level2"><a href="#e3xx_usage_sensors">The sensor API</a><ul><li class="level3"><a href="#e310_sensors">E31X Sensors</a></li>
<li class="level3"><a href="#e320_sensors">E320 Sensors</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#e3xx_rasm">Remote Management</a><ul><li class="level2"><a href="#e3xx_rasm_mender">Mender: Remote update capability</a></li>
<li class="level2"><a href="#e3xx_rasm_salt">Salt: Remote configuration management and execution</a></li>
</ul>
</li>
<li class="level1"><a href="#e3xx_troubleshooting">Troubleshooting</a><ul><li class="level2"><a href="#e3xx_troubleshooting_bist">E320 Built-in Self-Test (BiST)</a></li>
</ul>
</li>
<li class="level1"><a href="#e3xx_theory_of_ops">Theory of Operation</a></li>
<li class="level1"><a href="#e3xx_software_dev">Modifying and compiling UHD and MPM for the E320</a><ul><li class="level2"><a href="#e3xx_software_dev_mpm_native">Compiling MPM natively</a></li>
<li class="level2"><a href="#e3xx_software_dev_sdk">Obtaining an SDK</a></li>
<li class="level2"><a href="#e3xx_software_dev_sdkusage">SDK Usage</a><ul><li class="level3"><a href="#e3xx_software_dev_uhd">Building UHD</a></li>
<li class="level3"><a href="#e3xx_software_dev_gr">Building GNU Radio</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#e31x_device">E310-specific Features</a><ul><li class="level2"><a href="#e31x_hw_front_panel">Front Panel</a></li>
<li class="level2"><a href="#e31x_hw_rear_panel">Rear Panel</a></li>
<li class="level2"><a href="#e31x_hw_sync">Clock and Time Synchronization</a></li>
<li class="level2"><a href="#e31x_hw_pps">PPS - Pulse Per Second</a></li>
<li class="level2"><a href="#e31x_hw_gps">Internal GPS</a></li>
<li class="level2"><a href="#e31x_hw_gpio">Internal GPIO</a></li>
<li class="level2"><a href="#e31x_hw_chipscope">Debugging custom FPGA designs with Xilinx Chipscope</a></li>
<li class="level2"><a href="#e312_battery">Battery notes</a><ul><li class="level3"><a href="#e312_battery_connector">Connector</a></li>
<li class="level3"><a href="#e312_battery_information">Driver</a></li>
<li class="level3"><a href="#e312_battery_calibration">Calibration Procedure</a></li>
</ul>
</li>
<li class="level2"><a href="#e31x_dboards">Daughterboard notes</a><ul><li class="level3"><a href="#e31x_dboard_e310_tuning">Frontend tuning</a></li>
<li class="level3"><a href="#e31x_dboard_e310_gain">Frontend gain</a></li>
<li class="level3"><a href="#e31x_dboard_e310_pll">Frontend LO lock status</a></li>
<li class="level3"><a href="#e31x_dboard_e310_band_select">Frontend Filter and Antenna Switches</a></li>
<li class="level3"><a href="#e31x_dboard_e310_frontend_a_switches">Frontend Side A Filter and Antenna Switches</a></li>
<li class="level3"><a href="#e31x_dboard_e310_frontend_b_switches">Frontend Side B Filter and Antenna Switches</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#e320_neon">E320-specific Features</a><ul><li class="level2"><a href="#e320_panels">Front and Rear Panel</a></li>
<li class="level2"><a href="#e320_gpio">Front Panel GPIO</a></li>
<li class="level2"><a href="#e320_eeprom_flags">EEPROM flags</a></li>
</ul>
</li>
<li class="level1"><a href="#e3xx_regmap">E3XX FPGA Register Map</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="e3xx_feature_list"></a>
Comparative features list</h1>
<p>There are two category of devices in the E3xx series.</p><ol type="1">
<li>E310 series which includes E310, E312 and E313.</li>
<li>E320 - OEM board-only and with enclosure.</li>
</ol>
<p>These devices have some differences in their hardware capabilities but both are 2-channel transmitter/receiver based on the AD9361 transceiver IC and provide two RF channels:</p>
<ul>
<li>TX band: 47 MHz to 6.0 GHz</li>
<li>RX band: 70 MHz to 6.0 GHz</li>
<li>56 MHz of instantaneous bandwidth</li>
<li>2 RX DDC chains in FPGA</li>
<li>2 TX DUC chain in FPGA</li>
</ul>
<h2><a class="anchor" id="e3xx_feature_list_e310"></a>
E310</h2>
<p>The E310/E312/E313 has a motherboard and a daughterboard in an enclosed module with one AD9361 IC with 2 RF channels.</p>
<ul>
<li>Hardware Capabilities:<ul>
<li>External PPS reference input</li>
<li>2 USB 2.0 Host ports</li>
<li>Configurable clock rate</li>
<li>Internal IMU</li>
<li>Internal GPS</li>
<li>Internal GPIO connector with UHD API control</li>
<li>External USB Connection for built-in JTAG debugger and serial console</li>
<li>Xilinx Zynq SoC with dual-core ARM Cortex A9 (Speed Grade 1 and 3) and Kintex-7 FPGA (XC7Z020)</li>
</ul>
</li>
<li>Software Capabilities:<ul>
<li>Full Linux system running on the ARM core</li>
<li>Runs MPM (see also <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>) (introduced in UHD v3.15.0.0)</li>
</ul>
</li>
<li>FPGA Capabilities:<ul>
<li>RFNoC capability</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="e3xx_feature_list_e320"></a>
E320</h2>
<p>The E320 is monolithic board with one AD9361 IC with 2 RF channels.</p>
<ul>
<li>Hardware Capabilities:<ul>
<li>Single SFP+ Transceivers (can be used with 1 GigE, 10 GigE, and Aurora)</li>
<li>External PPS input</li>
<li>External 10 MHz input</li>
<li>Configurable clock rate</li>
<li>Internal IMU</li>
<li>Internal GPSDO for timing, location, and 10 MHz reference clock + PPS</li>
<li>External GPIO Connector with UHD API control</li>
<li>External USB Connection for built-in JTAG debugger and serial console</li>
<li>Xilinx Zynq SoC with dual-core ARM Cortex A9 (Speedgrade 3) and Kintex-7 FPGA (XC7Z045)</li>
<li>Fan connector (for board-only version)</li>
</ul>
</li>
<li>Software Capabilities:<ul>
<li>Full Linux system running on the ARM core</li>
<li>Runs MPM (see also <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>)</li>
</ul>
</li>
<li>FPGA Capabilities:<ul>
<li>RFNoC capability</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="e310_overview"></a>
E310 Overview</h1>
<h2><a class="anchor" id="e310_zynq"></a>
The Zynq CPU/FPGA and host operating system</h2>
<p>The main CPU of the E310 is a Xilinx Zynq SoC XC7Z020. It is both a dual-core ARM Cortex A9 CPU and Kintex-7 FPGA on a single die. The CPU is clocked at 667 MHz (speed grade 1) and 866 MHz (speed grade 3).</p>
<p>The programmable logic (PL, or FPGA) section of the SoC is responsible for handling all sampling data, DMA connections, and any other high-speed utility such as custom RFNoC logic. The processing system (PS, or CPU) is running a custom-build OpenEmbedded-based Linux operating system. The OS is responsible for all the device and peripheral management, such as running MPM (see section <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>), running local, UHD sessions, etc.</p>
<h2><a class="anchor" id="e31x_migration"></a>
E310 Migration Guide to MPM architecture</h2>
<p>This section covers the details for porting your E310 to the new MPM architecture. MPM is a hardware daemon running on the Linux operating system on the ARM cores and responsible for the device to function as a USRP.</p>
<p>A large portion of hardware-specific setup is handled by the daemon.</p>
<p>Note that the SD cards shipped with E310s do not contain the latest filesystem images. In order to use MPM (see section <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>) and all its features, the SD cards need to be manually flashed. Refer to <a class="el" href="page_usrp_e3xx.html#update_sdcard">Updating the SD card</a> in order to upgrade to E310 with UHD v3.15.0.0 or above.</p>
<p>After updating the SD card, you should be able to connect your device to the host OS either via SSH or serial console. See sections <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_ssh">SSH connection</a> and <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_serial">Serial connection</a> respectively, for more details.</p>
<p>Once you are logged in on the device, you should be able to run uhd_usrp_probe or other UHD examples.</p>
<p>Here is a list of a changes with the latest E310 filesystem (UHD v3.15.0.0) that can affect customer usage and applications:</p>
<ol type="1">
<li>Hostname: The hostname for the devices have changed from ni-e3xx(-sg3) to <code>ni-e31x-$serial</code>. This makes it easier to identify devices. You can change the hostname by modifying the <code>/etc/hostname</code> file and rebooting.</li>
<li>"product" name: The "product" name for E310 is now "e310_&lt;speedgrade&gt;" i.e. e310_sg1 and e310_sg3 for speed grade 1 and 3 respectively. Note that the "type" for e310 remains the same as before i.e. "e3xx".</li>
<li>FPGA bit/bin/rpt file name and image target: <table class="doxtable">
<tr>
<th>FPGA type </th><th>Old filename </th><th>New filename  </th></tr>
<tr>
<td>IDLE Image (power saving mode) SG1 </td><td>usrp_e3xx_fpga_idle.bit </td><td>usrp_e310_sg1_idle_fpga.bit </td></tr>
<tr>
<td>IDLE Image (power saving mode) SG3 </td><td>usrp_e3xx_fpga_idle_sg3.bit </td><td>usrp_e310_sg3_idle_fpga.bit </td></tr>
<tr>
<td>NORMAL Image SG1 </td><td>usrp_e310_fpga.bit </td><td>usrp_e310_sg1_fpga.bit </td></tr>
<tr>
<td>NORMAL Image SG3 </td><td>usrp_e310_fpga_sg3.bit </td><td>usrp_e310_sg3_fpga.bit </td></tr>
</table>
The names of the FPGA build targets have been modified but the old FPGA targets would continue to work as before. The generated bit files names in the build directory will be new as mentioned above.<ul>
<li>E310_&lt;speedgrade&gt; for default image</li>
<li>E310_&lt;speedgrade&gt;_RFNOC for RFNOC image (contains a few blocks)</li>
<li>E310_&lt;speedgrade&gt;_IDLE to build idle image (Doesn't need to modified for most cases)</li>
</ul>
</li>
<li>Loading FPGA image: The device arg "fpga=" can now only be used in the uhd_image_loader; it can no longer be used to update the fpga image in other UHD applications. This tooling now matches X310, E320, N3XX, etc. devices. See section <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_fpga_update">Updating the FPGA</a> for details.</li>
<li>With UHD v3.15.0.0. or higher, a lot of UHD dependencies have been upgraded too e.g. Boost, CMake, etc. The filesystem now runs a newer Linux kernel (e.g. linux-yocto_4.15 or higher). Existing customer applications might need to be updated in order to use the new filesystem and new UHD.</li>
<li>In order to build a custom filesystem, refer to <a class="el" href="page_usrp_e3xx.html#e3xx_fsbuild">Building custom filesystems and SD card images</a> for more details.</li>
<li>E310 filesystem no longer contains GNURadio by default. Custom filesystems are need to run GNURadio.</li>
<li>The network mode (streaming through RJ-45) for the E310 is not supported. In order to use the network mode use UHD 3.9 LTS release.</li>
<li>Refer section <a class="el" href="page_usrp_e3xx.html#e312_battery">Battery notes</a> for changes related to the battery.</li>
<li>Subdev spec has been changed from "A:A and A:B" to "A:0 and A:1" to match X310, N3xx and E320.</li>
</ol>
<h1><a class="anchor" id="e320_overview"></a>
E320 Overview</h1>
<h2><a class="anchor" id="e320_zynq"></a>
The Zynq CPU/FPGA and host operating system</h2>
<p>The main CPU of the E320 is a Xilinx Zynq SoC XC7Z045. It is both a dual-core ARM Cortex A9 CPU and Kintex-7 FPGA on a single die. The CPU is clocked at 1GHz (speed grade 3).</p>
<p>The programmable logic (PL, or FPGA) section of the SoC is responsible for handling all sampling data, the 1/10 GigE network connections, and any other high-speed utility such as custom RFNoC logic. The processing system (PS, or CPU) is running a custom-build OpenEmbedded-based Linux operating system. The OS is responsible for all the device and peripheral management, such as running MPM (see section <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>), configuring the network interfaces, running local UHD sessions, etc.</p>
<p>It is possible to connect to the host OS either via SSH or serial console (see sections <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_ssh">SSH connection</a> and <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_serial">Serial connection</a>, respectively).</p>
<h2><a class="anchor" id="e320_micro"></a>
The STM32 microcontroller</h2>
<p>The STM32 microcontroller controls various low-level features of the E320 series motherboard: It controls the power sequencing, reads out fan speeds and some of the temperature sensors. It is connected to the Zynq via an I2C bus.</p>
<p>It is possible to log into the STM32 using the serial interface (see <a class="el" href="page_usrp_e3xx.html#e320_getting_started_serial_micro">Connecting to the microcontroller</a>). This will allow certain low-level controls, such as remote power cycling should the CPU have become unresponsive for whatever reason.</p>
<h2><a class="anchor" id="e3xx_sdcard"></a>
The SD card</h2>
<p>The E310/E312/E313/E320 use a micro SD card as its main storage. The entire root file system (Linux kernel, libraries) and any user data are stored on this SD card.</p>
<p>The SD card is partitioned into four partitions:</p>
<ul>
<li>Boot partition (contains the bootloader). This partition usually does not require any modifications.</li>
<li>A data partition, mounted in /data. This is the only partition that is not erased during file system updates.</li>
<li>Two identical system partitions (root file systems). These contain the operating system and the home directory (anything mounted under / that is not the data or boot partition). The reason there are two of these is to enable remote updates: An update running on one partition can update the other one without any effect to the currently running system. Note that the system partitions are erased during updates and are thus unsuitable for permanently storing information.</li>
</ul>
<p>Note: It is possible to access the currently inactive root file system by mounting it. After logging into the device using serial console or SSH (see the following two sections), run the following commands: </p><pre class="fragment">$ mkdir temp
$ mount /dev/mmcblk0p3 temp
$ ls temp # You are now accessing the idle partition:
bin   data  etc   lib         media  proc  sbin  tmp    usr
boot  dev   home  lost+found  mnt    run   sys   uboot  var
</pre><p>The device node in the mount command will likely differ, depending on which partition is currently already mounted.</p>
<h1><a class="anchor" id="e3xx_getting_started"></a>
Getting started</h1>
<p>This will run you through the first steps relevant to getting your USRP E3XX up and running. Note: This guide was creating on an Ubuntu machine, and other distributions or OS's may have different names/methods.</p>
<h2><a class="anchor" id="e3xx_getting_started_assembling"></a>
Assembling the E3XX</h2>
<p>Unlike the X300 or N200 series, there is no assembly required for all E3xx devices as E310 motherboard and daughterboard comes in an enclosure and E320, on the other hand is a monolithic board (in board-only version) or comes in an enclosure.</p>
<p>Checklist:</p><ul>
<li>Connect power and network</li>
<li>Read security settings</li>
<li>Connect clocking (if required)</li>
</ul>
<h2><a class="anchor" id="e3xx_getting_started_fs_update"></a>
Updating the file system</h2>
<h3><a class="anchor" id="e31x_fs"></a>
E310/E312/E313 file system</h3>
<p>The SD cards shipped with E310s do not contain the latest filesystem images. In order to use MPM and all its features, the SD cards need to be manually flashed. Refer to <a class="el" href="page_usrp_e3xx.html#update_sdcard">Updating the SD card</a> in order to upgrade to E310 with UHD v3.15.0.0 or above. Once it has been upgraded to the new filesystem, Mender can be used to remotely update the filesystems. For details on using Mender, see Section <a class="el" href="page_usrp_e3xx.html#e3xx_rasm_mender">Mender: Remote update capability</a>.</p>
<h3><a class="anchor" id="e320_fs"></a>
E320 file system</h3>
<p>Before doing any major work with a newly acquired USRP E320, it is recommended to update the file system. For the OEM/Board-only version of E320, the SD card is physically accessible and filesystem update can be accomplished directly by using Mender or externally by manually writing an image onto a micro SD card and inserting it. For the enclosure version of E320, Mender update is required as there is no direct physical access to the device. For details on using Mender, see Section <a class="el" href="page_usrp_e3xx.html#e3xx_rasm_mender">Mender: Remote update capability</a> .</p>
<h3><a class="anchor" id="update_sdcard"></a>
Updating the SD card</h3>
<p>Manual updating is simply loading an image on the micro SD card. The first step in that process is to obtain an image.</p>
<p>To obtain the default micro SD card image for a specific version of UHD, install that version of UHD (E320 - 3.13.0.2 or later, E310 - 3.15.0.0 or later) on a host system with Internet access and run: </p><pre class="fragment">$ uhd_images_downloader -t &lt;e310/e320&gt; -t sdimg
</pre><p>The image will be downloaded to <code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_&lt;e310/e320&gt;_fs.sdimg</code>, where <code>&lt;UHD_INSTALL_DIR&gt;</code> is the UHD installation directory.</p>
<p>To load an image onto the micro SD card, connect the card to the host and run: </p><pre class="fragment">$ sudo dd if=&lt;YOUR_IMAGE&gt; of=/dev/&lt;YOUR_SD_CARD&gt; bs=1M
</pre><p>The <code>&lt;YOUR_IMAGE&gt;</code> is the path to the micro SD card image (i.e.<code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_&lt;e310/e320&gt;_fs.sdimg</code>).</p>
<p>The <code>&lt;YOUR_SD_CARD&gt;</code> device node depends on your operating system and which other devices are plugged in. Typical values are <code>sdb</code> or <code>mmcblk0</code>.<br />
</p>
<p>CAUTION: The Linux utility <code>dd</code> or <code>bmap</code> can cause unrecoverable data loss if the incorrect disk is selected, or if the parameters are input incorrectly. Ensure you have selected the correct input and output parameters for your system configuration.</p>
<p>The micro SD card used can be the original SD card shipped with the device or another one that is at least 8GB for E310 and at least 16 GB for E320 in size.</p>
<h1><a class="anchor" id="e3xx_fsbuild"></a>
Building custom filesystems and SD card images</h1>
<p>Ettus Research provides SD card images at regular intervals, but there can be good reasons to build custom SD cards, e.g., to test the very latest UHD or MPM for which there has not been an SD card release, to add own applications to the SD card, or to run a modified version of UHD.</p>
<p>Note that building SD cards is very disk space and RAM intensive.</p>
<h2><a class="anchor" id="e3xx_fsbuild_docker"></a>
Using Docker to build filesystems</h2>
<p>Ettus Research provides a Docker containers to facilitate building filesystems. Refer to the <a href="https://github.com/EttusResearch/ettus-docker/blob/master/oe-build/README.md">README </a> for more details.</p>
<h2><a class="anchor" id="e3xx_getting_started_serial"></a>
Serial connection</h2>
<p>It is possible to gain root access to the device using a serial terminal emulator. Most Linux, OSX, or other Unix flavours have a tool called 'screen' which can be used for this purpose, by running the following command: </p><pre class="fragment">$ sudo screen /dev/ttyUSB2 115200
</pre><p>In this command, we prepend 'sudo' to elevate user privileges (by default, accessing serial ports is not available to regular users), we specify the device node (in this case, <code>/dev/ttyUSB2</code>), and the baud rate (115200).</p>
<p>The exact device node depends on your operating system's driver and other USB devices that might be already connected. Modern Linux systems offer alternatives to simply trying device nodes; instead, the OS might have a directory of symlinks under <code>/dev/serial/by-id</code>:</p>
<p>For E310: </p><pre class="fragment">$ ls /dev/serial/by-id
/dev/serial/by-id/usb-FTDI_FT230X_Basic_UART_DQ0041HO-if00-port0
</pre><p>For E320: </p><pre class="fragment">$ ls /dev/serial/by-id
/dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if00-port0
/dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0
/dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6A6C-if00-port0
/dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6A6C-if01-port0
</pre><p>Note: Exact names depend on the host operating system version and may differ.</p>
<p>Every E310 device connected to USB will by default show up as one device. The device labeled "FTDI_FT230X_Basic_UART_DQ0041HO" connects to Linux.</p>
<p>Every E320 device connected to USB will by default show up as four different devices. The devices labeled "USB_to_UART_Bridge_Controller" are the devices that offer a serial prompt. The one with the <code>if01</code> suffix connects to Linux, whereas the one with <code>if00</code> suffix connects to the STM32 microcontroller. If you have multiple E320 devices connected, you may have to try out multiple devices. In this case, to use this symlink instead of the raw device node address, modify the command above to:</p>
<p>For E310: </p><pre class="fragment">$ sudo screen /dev/serial/by-id/usb-FTDI_FT230X_Basic_UART_DQ0041HO-if00-port0 115200
</pre><p>For E320: </p><pre class="fragment">$ sudo screen /dev/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6A6C-if01-port0 115200
</pre><p>You should be presented with a shell prompt similar to the following: </p><pre class="fragment">root@ni-&lt;e31x/e320&gt;-&lt;serial&gt;:~#
</pre><p>On this prompt, you can enter any Linux command available. Using the default configuration, the serial console will also show all kernel log messages (unlike when using SSH, for example), and give access to the boot loader (U-boot prompt). This can be used to debug kernel or bootloader issues more efficiently than when logged in via SSH.</p>
<h3><a class="anchor" id="e320_getting_started_serial_micro"></a>
Connecting to the microcontroller</h3>
<p>The STM32 microcontroller (which controls the power sequencing, among other things) also has a serial console available. To connect to the microcontroller, use the other UART device. In the example above: </p><pre class="fragment">$ sudo screen /dev/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if00-port0 115200
</pre><p>It provides a very simple prompt. The command 'help' will list all available commands. A direct connection to the microcontroller can be used to hard-reset the device without physically accessing it (i.e., emulating a power button press) and other low-level diagnostics.</p>
<h2><a class="anchor" id="e3xx_getting_started_ssh"></a>
SSH connection</h2>
<p>The USRP E310 devices have just one network connection: RJ-45 connector while the USRP E320 has two network connections: One SFP port, and an RJ-45 connector.</p>
<p>The RJ-45 connection is by default configured by DHCP; by plugging it into a 1 Gigabit switch on a DHCP-capable network, it will get assigned an IP address and thus be accessible via ssh.</p>
<p>In case your network setup does not include a DHCP server, refer to the section <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_serial">Serial connection</a>. A serial login can be used to assign an IP address manually.</p>
<p>After the device obtained an IP address you can log in from a Linux or OSX machine by typing: </p><pre class="fragment">$ ssh root@ni-&lt;e31x/e320&gt;-&lt;serial&gt; # Replace with your actual device name!
</pre><p>Depending on your network setup, using a <code>.local</code> domain may work: </p><pre class="fragment">$ ssh root@ni-&lt;e31x/e320&gt;-&lt;serial&gt;.local
</pre><p>Of course, you can also connect to the IP address directly if you know it (or set it manually using the serial console).</p>
<p>Note: The device's hostname is derived from its serial number by default (<code>ni-&lt;e31x/e320&gt;-&lt;SERIAL&gt;</code>). You can change the hostname by modifying the <code>/etc/hostname</code> file and rebooting.</p>
<p>On Microsoft Windows, the connection can be established using a tool such as Putty, by selecting a username of root without password.</p>
<p>Like with the serial console, you should be presented with a prompt like the following: </p><pre class="fragment">root@ni-&lt;e31x/e320&gt;-&lt;serial&gt;:~#
</pre><h2><a class="anchor" id="e3xx_getting_started_connectivity"></a>
Network Connectivity</h2>
<p>The RJ45 port (eth0) comes up with a default configuration of DHCP, that will request a network address from your DHCP server (if available on your network).</p>
<p>The factory settings are as follows: </p><pre class="fragment">eth0 (DHCP):

    [Match]
    Name=eth0

    [Network]
    DHCP=v4

    [DHCPv4]
    UseHostname=false
</pre><p>E320 has an extra SFP+ (sfp0) port which is configured with static address 192.168.10.2/24. The configuration for the sfp0 port is stored in /etc/systemd/networkd/sfp0.network.</p>
<p>For configuration please refer to the <a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">systemd-networkd manual pages</a></p>
<p>The factory settings are as follows: </p><pre class="fragment">sfp0 (static):

    [Match]
    Name=sfp0

    [Network]
    Address=192.168.10.2/24

    [Link]
    MTUBytes=8000
</pre><p>Note: Care needs to be taken when editing these files on the device, since vi / vim sometimes generates undo files (e.g. /etc/systemd/networkd/sfp0.network~), that systemd-networkd might accidentally pick up.</p>
<p>Note: Temporarily setting the IP addresses via ifconfig etc will only change the value until the next reboot or reload of the FPGA image.</p>
<h2><a class="anchor" id="e3xx_getting_started_security"></a>
Security-related settings</h2>
<p>The E320 ships without a root password set. It is possible to ssh into the device by simply connecting as root, and thus gaining access to all subsystems. To set a password, run the command </p><pre class="fragment">$ passwd
</pre><p>on the device.</p>
<h2><a class="anchor" id="e3xx_getting_started_fpga_update"></a>
Updating the FPGA</h2>
<p>Updating the FPGA follows the same procedure as other USRPs. Use the <code>uhd_image_loader</code> command line utility to upload a new FPGA image onto the device. The command can be run on the host to load the image via RJ-45 network connection or it can be run on the device.</p>
<p>A common reason to update the FPGA image is in the case of a UHD/FPGA compat number mismatch (for example, if UHD has been updated, and now expects a newer version of the FPGA than is on the device). In this case, simply run </p><pre class="fragment">$ uhd_images_downloader
</pre><p>to update the local cache of FPGA images. Then, run </p><pre class="fragment">$ uhd_image_loader --args type=e3xx,addr=ni-&lt;e31x/e320&gt;-&lt;serial&gt;
</pre><p>to update the FPGA using the default settings. Replace the addr above with the correct device address. If a custom FPGA image is targeted for uploading, use the <code>--fpga-path</code> command line argument. Run </p><pre class="fragment">$ uhd_image_loader --help
</pre><p>to see a full list of command line options. Note that updating the FPGA image will force a reload of the FPGA, and in case of E320 it will temporarily take down the SFP network interfaces (and temporary settings, such as applied via <code>ifconfig</code> on the command line, will be lost).</p>
<h1><a class="anchor" id="e3xx_usage"></a>
Using an E3XX USRP from UHD</h1>
<p>Like any other USRP, all E series USRPs are controlled by the UHD software. To integrate a USRP E310/E312/E313/E320 into your C++ application, you would generate a UHD device in the same way you would for any other USRP:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;type=e3xx&quot;</span>);</div></div><!-- fragment --><p>For a list of which arguments can be passed into make(), see Section <a class="el" href="page_usrp_e3xx.html#e3xx_usage_device_args">Device arguments</a>.</p>
<h2><a class="anchor" id="e3xx_usage_device_args"></a>
Device arguments</h2>
<table class="doxtable">
<tr>
<th>Key </th><th>Description </th><th>Example Value  </th></tr>
<tr>
<td>addr </td><td>IPv4 address of primary SFP+/RJ-45 port to connect to </td><td>addr=192.168.30.2 </td></tr>
<tr>
<td>find_all </td><td>When using broadcast, find all devices, even if unreachable via CHDR. </td><td>find_all=1 </td></tr>
<tr>
<td>master_clock_rate </td><td>Master Clock Rate in Hz. Default is 16 MHz. </td><td>master_clock_rate=30.72e6 </td></tr>
<tr>
<td>skip_dram </td><td>Ignore DRAM FIFO block. Connect TX streamers straight into DUC or radio. </td><td>skip_dram=1 </td></tr>
<tr>
<td>skip_ddc </td><td>Ignore DDC block. Connect Rx streamers straight into radio. </td><td>skip_ddc=1 </td></tr>
<tr>
<td>skip_duc </td><td>Ignore DUC block. Connect Tx streamers or DRAM straight into radio. </td><td>skip_duc=1 </td></tr>
<tr>
<td>skip_init </td><td>Skip the initialization process for the device. </td><td>skip_init=1 </td></tr>
<tr>
<td>discovery_port </td><td>Override default value for MPM discovery port. </td><td>discovery_port=49700 </td></tr>
<tr>
<td>rpc_port </td><td>Override default value for MPM RPC port. </td><td>rpc_port=49701 </td></tr>
</table>
<h2><a class="anchor" id="e3xx_usage_sensors"></a>
The sensor API</h2>
<h3><a class="anchor" id="e310_sensors"></a>
E31X Sensors</h3>
<p>Like other USRPs, the E310 series has RF and motherboard sensors. When using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>, the following API calls are relevant to interact with the sensor API:</p>
<ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">uhd::usrp::multi_usrp::get_mboard_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">uhd::usrp::multi_usrp::get_mboard_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">uhd::usrp::multi_usrp::get_tx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">uhd::usrp::multi_usrp::get_rx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">uhd::usrp::multi_usrp::get_tx_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">uhd::usrp::multi_usrp::get_rx_sensor()</a></li>
</ul>
<p>The following motherboard sensors are always available:</p><ul>
<li><code>temp_fpga</code>: temperature (in Celsius) of the FPGA die</li>
<li><code>temp_mb</code>: temperature (in Celsius) of the motherboard</li>
<li><code>ref_locked</code>: This will check that all the daughter boards have locked to the reference clock.</li>
</ul>
<h3><a class="anchor" id="e320_sensors"></a>
E320 Sensors</h3>
<p>Like other USRPs, the E320 series has RF and motherboard sensors. When using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>, the following API calls are relevant to interact with the sensor API:</p>
<ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">uhd::usrp::multi_usrp::get_mboard_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">uhd::usrp::multi_usrp::get_mboard_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">uhd::usrp::multi_usrp::get_tx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">uhd::usrp::multi_usrp::get_rx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">uhd::usrp::multi_usrp::get_tx_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">uhd::usrp::multi_usrp::get_rx_sensor()</a></li>
</ul>
<p>The following motherboard sensors are always available:</p><ul>
<li><code>temp_internal</code>: temperature (in Celsius) of Temperature Sensor on board</li>
<li><code>temp_fpga</code>: temperature (in Celsius) of the FPGA die</li>
<li><code>temp_rf_channelA</code>: temperature (in Celsius) near power amplifier RF A</li>
<li><code>temp_rf_channelB</code>: temperature (in Celsius) near power amplifier RF B</li>
<li><code>temp_main_power</code>: temperature (in Celsius) near power supply</li>
<li><code>gps_locked</code>: GPS lock</li>
<li><code>gps_time</code>: GPS time in seconds sin ce the epch</li>
<li><code>gps_tpv</code>: A TPV report from GPSd serialized as JSON</li>
<li><code>gps_sky</code>: A SKY report from GPSd serialized as JSON</li>
<li><code>ref_locked</code>: This will check that all the daughter boards have locked to the external/internal reference clock.</li>
<li><code>fan</code>: get fan speed (in rpm)</li>
</ul>
<h1><a class="anchor" id="e3xx_rasm"></a>
Remote Management</h1>
<h2><a class="anchor" id="e3xx_rasm_mender"></a>
Mender: Remote update capability</h2>
<p>Mender is a third-party software that enables remote updating of the root file system without physically accessing the device (see also the <a href="https://mender.io">Mender website</a>). Mender can be executed locally on the device, or a Mender server can be set up which can be used to remotely update an arbitrary number of USRP devices. Mender servers can be self-hosted, or hosted by Mender (see <a href="https://mender.io">mender.io</a> for pricing and availability).</p>
<p>When updating the file system using Mender, the tool will overwrite the root file system partition that is not currently mounted (note: every SD card comes with two separate root file system partitions, only one is ever used at a single time). Any data stored on that partition will be permanently lost. After updating that partition, it will reboot into the newly updated partition. Only if the update is confirmed by the user, the update will be made permanent. This means that if an update fails, the device will be always able to reboot into the partition from which the update was originally launched (which presumably is in a working state). Another update can be launched now to correct the previous, failed update, until it works. See also Section <a class="el" href="page_usrp_e3xx.html#e3xx_sdcard">The SD card</a>.</p>
<p>Note: For E310, the SD cards that are shipped with the device do not have the latest UHD and do not support MPM by default. The SD cards will have to be flashed with UHD v3.15.0.0 or above to be able to use mender. After the first upgrade, mender can be used for future upgrades. Refer to the migration guide. <a class="el" href="page_usrp_e3xx.html#e31x_migration">E310 Migration Guide to MPM architecture</a></p>
<p>To initiate an update from the device itself, download a Mender artifact containing the update itself. These are files with a <code>.mender</code> suffix.</p>
<p>Then run mender on the command line: </p><pre class="fragment">$ mender -rootfs /path/to/latest.mender
</pre><p>The artifact can also be stored on a remote server: </p><pre class="fragment">$ mender -rootfs http://server.name/path/to/latest.mender
</pre><p>This procedure will take a while. After mender has logged a successful update, reboot the device: </p><pre class="fragment">$ reboot
</pre><p>If the reboot worked, and the device seems functional, commit the changes so the boot loader knows to permanently boot into this partition: </p><pre class="fragment">$ mender -commit
</pre><p>To identify the currently installed Mender artifact from the command line, the following file can be queried: </p><pre class="fragment">$ cat /etc/mender/artifact_info
</pre><p>If you are running a hosted server, the updates can be initiated from a web dashboard. From there, you can start the updates without having to log into the device, and can update groups of USRPs with a few clicks in a web GUI. The dashboard can also be used to inspect the state of USRPs. This is simple way to update groups of rack-mounted USRPs with custom file systems.</p>
<h2><a class="anchor" id="e3xx_rasm_salt"></a>
Salt: Remote configuration management and execution</h2>
<p>Salt (also known as SaltStack, see <a href="https://saltstack.com">Salt Website</a>) is a Python-based tool for maintaining fleets of remote devices. It can be used to manage USRP E31X/E320 remotely for all types of settings that are not controlled by UHD. For example, if an operator would like to reset the root password on multiple devices, or install custom software, this tool might be a suitable choice.</p>
<p>Salt is a third-party project with its <a href="https://docs.saltstack.com/en/latest/">own documentation</a>, which should be consulted for configuring it. However, the Salt minion is installed by default on every E31X/E320 device. To start it, simply log on to the device and run: </p><pre class="fragment">$ systemctl start salt-minion
</pre><p>To permanently enable it at every boot, run (this won't by itself launch the salt-minion): </p><pre class="fragment">$ systemctl enable salt-minion
</pre><p>To make use of Salt, both the device needs to be configured (the "minion") and, typically, a server to act as the Salt master. Refer to the Salt documentation on how to configure the minion and the master. A typical sequence to get started will look like this:</p>
<ol type="1">
<li>Install the salt-master package on the server (e.g. by running <code>apt install salt-master</code> if the server is an Ubuntu system), and make sure the Salt master is running.</li>
<li>Add the network address / hostname of that server to the <code>/etc/salt/minion</code> file on the device by editing the <code>master:</code> line.</li>
<li>Launch the Salt minion on the USRP by running the command <code>systemctl start salt-minion</code>.</li>
<li>The minion will try to connect to the master. You need to authorize the minion by running <code>salt-key -a $hostname</code> where <code>$hostname</code> is the name of the minion.</li>
<li>Once the device is authorized, you can try various commands to see if the communication was established:</li>
</ol>
<div class="fragment"><div class="line">$ [sudo] salt &#39;*&#39; test.ping</div><div class="line">ni-e3xx-$serial:</div><div class="line">    True</div><div class="line">$ [sudo] salt &#39;*&#39; network.interfaces</div><div class="line">ni-e3xx-$serial:</div><div class="line">    ----------</div><div class="line">    eth0:</div><div class="line">        ----------</div><div class="line">        hwaddr:</div><div class="line">            02:00:03:11:fe:00</div><div class="line">        inet:</div><div class="line">            |_</div><div class="line">              ----------</div><div class="line">              address:</div><div class="line">                  xx.xx.xx.xx</div><div class="line">              broadcast:</div><div class="line">                  xx.xx.xx.xx</div><div class="line">              label:</div><div class="line">                  eth0</div><div class="line">              netmask:</div><div class="line">                  255.255.254.0</div><div class="line">        up:</div><div class="line">            True</div><div class="line"># [...]</div></div><!-- fragment --><h1><a class="anchor" id="e3xx_troubleshooting"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="e3xx_troubleshooting_bist"></a>
E320 Built-in Self-Test (BiST)</h2>
<p>The E320 series devices have a built-in self-test that can be used to verify the hardware. It is not automatically run, but it can be invoked anytime by running the <code>e320_bist</code> executable. Calling </p><pre class="fragment">e320_bist -h
</pre><p>will list the available options. Tests can be run by specifying their name, e.g. </p><pre class="fragment">e320_bist gpsdo
</pre><p>will test the functionality of the GPSDO. Calling <code>e320_bist standard</code> will run a standard set of tests, verifying some base peripherals such as the RTC, the fan and temperature sensors, etc.</p>
<p>Some tests require special hardware connected. For example, for the <code>sfp_loopback</code> tests, a loopback module must be plugged into the SFP+.</p>
<p>Tests may also load different FPGA images, if required. The aforementioned SFP tests will load the Aurora FPGA image and use Aurora to run the BER tests on the SFP port. This is particularly relevant if either a custom image was loaded, or if there is an active SSH or other connection coming in via the SFP+ ports.</p>
<h1><a class="anchor" id="e3xx_theory_of_ops"></a>
Theory of Operation</h1>
<p>All E series devices are on the MPM architecture (see also: <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>). Inside the Linux operating system running on the ARM cores, there is a hardware daemon which needs to be active in order for the device to function as a USRP (it is enabled to run by default).</p>
<p>A large portion of hardware-specific setup is handled by the daemon.</p>
<h1><a class="anchor" id="e3xx_software_dev"></a>
Modifying and compiling UHD and MPM for the E320</h1>
<p>E320 devices ship with all relevant software installed on the SD card. Updating UHD and/or MPM on the SD card is typically easiest done by updating the filesystem image (see Section <a class="el" href="page_usrp_e3xx.html#e3xx_rasm_mender">Mender: Remote update capability</a>). However, it is certainly possible to compile UHD and MPM by hand, e.g., in order to modify and try out changes without having to build entire filesystems in between. At Ettus R&amp;D, this mode of operation is often used for rapid iteration cycles.</p>
<p>While on E310 the SD cards that are shipped with the device do not have the latest UHD and do not support MPM by default. The SD cards will have to be flashed with UHD v3.15.0.0 or above to be able to use mender. After the first upgrade, mender can be used for future upgrades. Refer to the migration guide. <a class="el" href="page_usrp_e3xx.html#e31x_migration">E310 Migration Guide to MPM architecture</a></p>
<h2><a class="anchor" id="e3xx_software_dev_mpm_native"></a>
Compiling MPM natively</h2>
<p>In general, compiling natively is not a recommended way of compiling code for the ARM processors. However, in the case of MPM, the amount of C++ code that needs to be compiled is very little, and a full compile of MPM will take a few minutes even on the device. First, you need to get a copy of the MPM source code onto your device. If you have an internet connection, you can use git to pull it directly from the Ettus repository (all commands are run on the device itself, inside the home directory): </p><pre class="fragment">$ git clone https://github.com/EttusResearch/uhd.git
</pre><p>You can also SSHFS it from another computer: </p><pre class="fragment">$ mkdir uhd # Create a new, empty directory called uhd
$ sshfs user@yourcomputer:src/uhd uhd # This will mount ~/src/uhd from the remote machine to ~/uhd on the device
</pre><p>Now, create a build directory and use the regular cmake/make procedure to kick off a build. It can be advantageous (especially for slow network connections) to create the build directory outside of the repository directory: </p><pre class="fragment">$ mkdir build_mpm
$ cd build_mpm # You are now in /home/root/build_mpm
$ cmake -DMPM_DEVICE=e320 ../uhd/mpm
$ make -j2 install # This will take several minutes
</pre><p>Note that this overwrites your system MPM. You can install MPM to another location by specifying <code>-DCMAKE_INSTALL_PREFIX</code>, but make sure to update all of your paths appropriately.</p>
<p>If you prefer cross-compiling MPM the same way as UHD, refer to the following sections and adapt the instructions for UHD appropriately.</p>
<h2><a class="anchor" id="e3xx_software_dev_sdk"></a>
Obtaining an SDK</h2>
<p>The recommended way to develop software for the E31X/E320 is to cross-compile. By running the compiles on a desktop or laptop computer, you will be able to speed up compile times considerably (compiling UHD natively would take many hours).</p>
<p>SDKs are distributed along with other binaries. They contain a cross-compiler, a cross-linker, a cross-debugger, and all the libraries available on the device to mirror its environment. Note: The SDK for E310 has been updated for UHD versions above v.3.15.0.0. Refer to the migration guide for details. <a class="el" href="page_usrp_e3xx.html#e31x_migration">E310 Migration Guide to MPM architecture</a></p>
<p>To unpack the SDK, simply execute it after downloading it: </p><pre class="fragment">$ cd /usr/local/share/uhd/images # Change this to where your images are stored
$ ./oecore-x86_64-cortexa9hf-neon-toolchain-nodistro.0.sh
</pre><p>If this doesn't work, the executable permissions of the file might have been lost (this can occur with some versions of Python). In that case, add those permissions back before executing the <code>.sh</code> file: </p><pre class="fragment">$ chmod +x oecore-x86_64-cortexa9hf-neon-toolchain-nodistro.0.sh
</pre><p>Executing the <code>.sh</code> file will prompt you for an installation path. Please ensure you have sufficient disk space, as each of the SDKs may require several gigabytes of disk space (depending on the image flavor selected).</p>
<p>This will allow you to compile UHD as well as (depending on the image flavor) other software.</p>
<p>Please note, that while several toolchains can be installed in parallel, they have to be installed to different directories.</p>
<h2><a class="anchor" id="e3xx_software_dev_sdkusage"></a>
SDK Usage</h2>
<p>Having installed the toolchain in the last step, in order to build software for your device open a new shell and type: </p><pre class="fragment">$ . $SDKPATH/environment-setup-armv7ahf-vfp-neon-oe-linux-gnueabi
</pre><p>This will modify the PATH, CC, CXX etc, environment variables and allow you to compile software for your device. To verify all went well you can try: </p><pre class="fragment">$ $CC -dumpmachine
</pre><p>which should return 'arm-oe-linux-gnueabi'.</p>
<h3><a class="anchor" id="e3xx_software_dev_uhd"></a>
Building UHD</h3>
<ol type="1">
<li>Obtain the UHD source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_e3xx.html#e3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Type the following in the build directory (assuming a build in host/build): <pre class="fragment"> $ cmake -DCMAKE_TOOLCHAIN_FILE=../host/cmake/Toolchains/oe-sdk_cross.cmake -DCMAKE_INSTALL_PREFIX=/usr .. # Add any CMake options you desire
 $ make # You can run make -j12 to compile on 12 processes at once
</pre></li>
</ol>
<p>Note: The UHD you are cross-compiling will not run on your host computer (the one where you're doing the development). Compiling UHD regularly on your host computer (with MPMD enabled) will allow you to talk to your device.</p>
<h3><a class="anchor" id="e3xx_software_dev_gr"></a>
Building GNU Radio</h3>
<ol type="1">
<li>Obtain the GNU Radio source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_e3xx.html#e3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Use the following commands to create a build directory, configure and compile gnuradio. You only need create the build directory once.</li>
</ol>
<div class="fragment"><div class="line">$ mkdir build-arm</div><div class="line">$ cd build-arm</div><div class="line">$ cmake -Wno-dev -DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchains/oe-sdk_cross.cmake \-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_GR_VOCODER=OFF -DENABLE_GR_ATSC=OFF \</div><div class="line">-DENABLE_GR_DTV=OFF -DENABLE_DOXYGEN=OFF ../ # Append any CMake options you desire</div></div><!-- fragment --><p>Several GNU Radio components depend on running binaries built for the build machine during compile. These binaries can be built and used for cross compiling, but this is an advanced topic.</p>
<h1><a class="anchor" id="e31x_device"></a>
E310-specific Features</h1>
<h2><a class="anchor" id="e31x_hw_front_panel"></a>
Front Panel</h2>
<div class="image">
<img src="e3x0_fp_overlay.png" alt="e3x0_fp_overlay.png"/>
<div class="caption">
USRP E310 Front panel</div></div>
<ul>
<li><b>RF A Group</b><ul>
<li><b>TX/RX LED</b>: Indicates that data is streaming on the TX/RX channel on frontend side A</li>
<li><b>RX2 LED</b>: Indicates that data is streaming on the RX2 channel on frontend side A</li>
</ul>
</li>
<li><b>RF B Group</b><ul>
<li><b>TX/RX LED</b>: Indicates that data is streaming on the TX/RX channel on frontend B</li>
<li><b>RX2 LED</b>: Indicates that data is streaming on the RX2 channel on frontend B</li>
</ul>
</li>
<li><b>PWR</b>: Power switch with integrated status LED, for status description see below.</li>
<li><b>SYNC</b>: Input port for external PPS signal</li>
<li><b>GPS</b>: Connection for the GPS antenna</li>
</ul>
<p>The status LED in the power switch indicates the power and charge status. Its behavior is firmware version dependent.</p>
<ul>
<li><b>Version 1</b> (original E310)<ul>
<li><b>Off</b>: Indicates device is off and not charging</li>
<li><b>Solid Red</b>: Indicates device is charging</li>
<li><b>Solid Green</b>: Indicates device is on</li>
<li><b>Fast Blinking Red</b>: Indicates an error code<ul>
<li>1 - Low voltage error</li>
<li>2 - Regulator low voltage error</li>
<li>3 - FPGA power error</li>
<li>4 - DRAM power error</li>
<li>5 - 1.8V rail power error</li>
<li>6 - 3.3V rail power error</li>
<li>7 - Daughterboard / TX power error</li>
<li>9 - Temperature error</li>
</ul>
</li>
</ul>
</li>
<li><b>Version 2</b> (E312 and upgraded E310)<ul>
<li><b>Off</b>: Indicates device is off and not charging</li>
<li><b>Slow Blinking Green</b>: Indicates device is off and charging</li>
<li><b>Fast Blinking Green</b>: Indicates device is on and charging</li>
<li><b>Solid Green</b>: Indicates device is on (and not charging, if E312)</li>
<li><b>Solid Orange</b>: Indicates device is on and discharging</li>
<li><b>Fast Blinking Orange</b>: Indicates device is on, discharging, and charge is below 10% charge</li>
<li><b>Fast Blinking Red</b>: Indicates an error code<ul>
<li>1 - Low voltage error</li>
<li>2 - Regulator low voltage error</li>
<li>3 - FPGA power error</li>
<li>4 - DRAM power error</li>
<li>5 - 1.8V rail power error</li>
<li>6 - 3.3V rail power error</li>
<li>7 - Daughterboard / TX power error</li>
<li>8 - Charger error</li>
<li>9 - Charger temperature error</li>
<li>10 - Battery low error</li>
<li>11 - Fuel Gauge temperature error</li>
<li>12 - Global (case) temperature error</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="e31x_hw_rear_panel"></a>
Rear Panel</h2>
<div class="image">
<img src="e3x0_rp_overlay.png" alt="e3x0_rp_overlay.png"/>
<div class="caption">
USRP E310 Rear Panel</div></div>
<ul>
<li><b>PWR</b>: Locking connector (Kycon KLDHCX-0202-A-LT) for the USRP-E Series power supply</li>
<li><b>1G ETH</b>: RJ45 port for Ethernet interfaces</li>
<li><b>USB</b>: USB 2.0 Port</li>
<li><b>SERIAL</b>: Micro USB connection for serial uart console</li>
</ul>
<h2><a class="anchor" id="e31x_hw_sync"></a>
Clock and Time Synchronization</h2>
<p>Unlike most USRP devices, the E310 does not have independent reference clock and time source inputs. It is possible, however, to discipline the internal reference clock using an external time (PPS) source connected to the SYNC input pin. The E310 FPGA has a subsystem that can use the PPS signal from the SYNC pin or the internal GPS to align edges of the reference clock to edges of a shared PPS signal. This alignment happens automatically when the time source in UHD is set to "gpsdo" or "external". Please note that because the SYNC input can only accept a PPS signal, the only supported value for the reference clock source is "internal". Also, keep in mind that the E310 does <em>not</em> have a GPS-disciplined oscillator like other USRPs, the value "gpsdo" for the time source was chosen for compatibility with other USRPs.</p>
<h2><a class="anchor" id="e31x_hw_pps"></a>
PPS - Pulse Per Second</h2>
<p>Using a PPS signal for timestamp synchronization requires a LVCMOS or a 5V logic input signal. An external PPS can be used to discipline the internal reference clock. This feature is automatically enabled with the time source is set to "external".</p>
<p>To test the PPS input, you can use the following tool from the UHD examples:</p>
<ul>
<li><p class="startli"><code>&lt;args&gt;</code> are device address arguments (optional if only one USRP device is on your machine)</p>
<p class="startli">cd &lt;install-path&gt;/lib/uhd/examples ./test_pps_input &ndash;args=&lt;args&gt;</p>
</li>
</ul>
<h2><a class="anchor" id="e31x_hw_gps"></a>
Internal GPS</h2>
<p>Your USRP-E Series device comes with an internal GPS. In order to get a lock on a satellite an external GPS antenna is required. The PPS from the internal GPS can be used to discipline the internal reference clock. This feature is automatically enabled when the time source is set to "gpsdo". Again, keep in mind that while the E310 does not have an actual GPS-disciplined oscillator (GPSDO) on the board, the value "gpsdo" was named such for better compatibility with code written for other devices.</p>
<p>The device provides a 3.3V supply voltage to an external antenna connected to the <em>GPS</em> port of your device. Note that this supply voltage is turned off in order to safe power upon destruction of the software object.</p>
<h2><a class="anchor" id="e31x_hw_gpio"></a>
Internal GPIO</h2>
<h3>Connector</h3>
<div class="image">
<img src="e3x0_gpio_conn.png" alt="e3x0_gpio_conn.png"/>
<div class="caption">
E3xx GPIO Connector</div></div>
 <h3>Pin Mapping</h3>
<ul>
<li>Pin 1: +3.3V</li>
<li>Pin 2: Reserved</li>
<li>Pin 3: Data[5]</li>
<li>Pin 4: Reserved</li>
<li>Pin 5: Data[4]</li>
<li>Pin 6: Data[0]</li>
<li>Pin 7: Data[3]</li>
<li>Pin 8: Data[1]</li>
<li>Pin 9: 0V</li>
<li>Pin 10: Data[2]</li>
</ul>
<p>Please see the <a class="el" href="page_gpio_api.html">E3x0/X3x0 GPIO API</a> for information on configuring and using the GPIO bus.</p>
<h2><a class="anchor" id="e31x_hw_chipscope"></a>
Debugging custom FPGA designs with Xilinx Chipscope</h2>
<h3>Connector</h3>
<div class="image">
<img src="e3x0_jtag_conn.png" alt="e3x0_jtag_conn.png"/>
<div class="caption">
E3xx JTAG Connector</div></div>
 <h3>Pin Mapping</h3>
<ul>
<li>Pin 1: TDO</li>
<li>Pin 2: 3.3V</li>
<li>Pin 3: TCK</li>
<li>Pin 4: TDI</li>
<li>Pin 5: 0V</li>
<li>Pin 6: TMS</li>
</ul>
<p>Xilinx chipscope allows for debugging custom FPGA designs similar to a logic analyzer. USRP-E series devices can be used with Xilinx chipscope using the internal JTAG connector.</p>
<p>Further information on how to use Chipscope can be found in the <em>Xilinx Chipscope Pro Software and Cores User Guide (UG029)</em>.</p>
<h2><a class="anchor" id="e312_battery"></a>
Battery notes</h2>
<p>The USRP E312 (and with upgraded firmware E310) supports LiIon Battery packs (e.g. AA Portable Power Corp, 749801-01).</p>
<h3><a class="anchor" id="e312_battery_connector"></a>
Connector</h3>
<p>The connector J1 on E312's motherboard is a Molex 53014-6310. The corresponding mating connector is a Molex 51004-0300.</p>
<div class="image">
<img src="e3xx_conn_photo.jpg" alt="e3xx_conn_photo.jpg"/>
<div class="caption">
Battery pack connector</div></div>
<p> The pins are as follows:</p><ul>
<li>Pin 1 (Red): VBat</li>
<li>Pin 2 (Black): GND</li>
<li>Pin 3 (White): Battery Thermistor</li>
</ul>
<h3><a class="anchor" id="e312_battery_information"></a>
Driver</h3>
<p>The battery information is exposed on the device via the sysfs directory under: </p><pre class="fragment">/sys/class/power_supply/e31x-battery/
</pre><p>and for the charger: </p><pre class="fragment">/sys/class/power_supply/e31x-charger/
</pre><p>The values can be accessed via libudev or manually e.g.: </p><pre class="fragment">$ root@ni-e31x-&lt;serial&gt;: cat /sys/class/power_supply/e31x-battery/status
</pre><p>The driver emits uevents on changes, that can be used to write custom UDev rules. Using UDev rules one can configure the USRP E3xx to shut down on certain events, such as low battery charge, high temperatures or AC power plug in.</p>
<p>The following example will cause the system to shut down at a reported temperature of 73C: </p><div class="fragment"><div class="line">SUBSYSTEM==<span class="stringliteral">&quot;power_supply&quot;</span>, ATTR{online}==<span class="stringliteral">&quot;1&quot;</span>, ATTR{temp}==<span class="stringliteral">&quot;730&quot;</span>, RUN+=<span class="stringliteral">&quot;/sbin/shutdown -h now&quot;</span></div></div><!-- fragment --><p>The sysfs property "capacity" is no longer supported by the battery driver in the latest filesystem. It was removed to comply with the Linux power supply class driver recommendations during the ongoing driver upstreaming process. The capacity may still be calculated by the customer application using the following formula (charge_now/charge_full) * 100</p>
<p>For more information, please see the udev manual pages and <a href="https://www.kernel.org/doc/Documentation/power/power_supply_class.txt">Kernel Power Supply Docs </a>.</p>
<h3><a class="anchor" id="e312_battery_calibration"></a>
Calibration Procedure</h3>
<p>In order for the fuel gauge to give a usable indication of remaining charge it needs to be calibrated. The procedure for calibration is as follows:</p>
<ol type="1">
<li>Completely discharge battery (e.g. by booting up without SD card, so OS doesn't auto shutdown)</li>
<li>Unplug the battery pack and external power</li>
<li>Reconnect the battery pack</li>
<li>Reconnect AC power and charge until charge completed.</li>
</ol>
<p>A faster (less accurate) calibration procedure is as follows:</p>
<ol type="1">
<li>Completely charge battery</li>
<li><p class="startli">Type:</p>
<p class="startli">$ echo 3200000 &gt; /sys/class/power_supply/e31x-battery/charge_now</p>
</li>
<li>Unplug AC power</li>
<li>Replug AC power and wait until charge completes</li>
</ol>
<h2><a class="anchor" id="e31x_dboards"></a>
Daughterboard notes</h2>
<p>The USRP E310 MIMO XCVR daughterboard features an integrated MIMO capable RF frontend.</p>
<h3><a class="anchor" id="e31x_dboard_e310_tuning"></a>
Frontend tuning</h3>
<p>The RF frontend has individually tunable receive and transmit chains. Both transmit and receive can be used in a MIMO configuration. For the MIMO case, both receive frontends share the RX LO, and both transmit frontends share the TX LO. Each LO is tunable between 50 MHz and 6 GHz.</p>
<p>As there is a single LO for each direction (RX and TX), this means that both channels need to use the same LO frequency (i.e., both RX channels share an LO frequency, and both TX channels share an LO frequency). If the two channels are supposed to receive on different frequencies, the digital tune stages need to be used for that. The two frequencies will need to be within the currently selected master clock rate, and the final bandwidths need to be chosen carefully. Example: Assume the master clock rate is set to 50 MHz, and we want to receive at 400 MHz and 440 MHz. We can set the LO to 420 MHz, which will sample the spectrum from 395 MHz to 445 MHz. The LO offsets for both channels need to be 20 MHz and -20 MHz respectively. However, the final bandwidth should be less than 10 MHz (preferably lower), or the signals would exhibit aliasing.</p>
<p>Because both channels share an LO, tuning one channel can possibly affect the other channel. It is advisable to read back the actual, current frequency from software before assuming the device is tuned to a specific frequency.</p>
<h3><a class="anchor" id="e31x_dboard_e310_gain"></a>
Frontend gain</h3>
<p>All frontends have individual analog gain controls. The receive frontends have 76 dB of available gain; and the transmit frontends have 89.5 dB of available gain. Gain settings are application specific, but it is recommended that users consider using at least half of the available gain to get reasonable dynamic range.</p>
<h3><a class="anchor" id="e31x_dboard_e310_pll"></a>
Frontend LO lock status</h3>
<p>The frontends provide a <em>lo-locked</em> sensor that can be queried through the UHD API.</p>
<div class="fragment"><div class="line"><span class="comment">// assumes &#39;usrp&#39; is a valid uhd::usrp::multi_usrp::sptr instance</span></div><div class="line"></div><div class="line"><span class="comment">// get status for rx frontend</span></div><div class="line">usrp-&gt;get_rx_sensor(<span class="stringliteral">&quot;lo-locked&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// get status for tx frontend</span></div><div class="line">usrp-&gt;get_tx_sensor(<span class="stringliteral">&quot;lo-locked&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="e31x_dboard_e310_band_select"></a>
Frontend Filter and Antenna Switches</h3>
<p>The transmit and receive filter banks uses switches to select between the available filters. These paths are also dependent on the antenna switch settings. Incorrectly setting the switches generally results in attenuated input / output power. Receive filters are band pass (series high &amp; low pass filters), transmit filters are low pass.</p>
<p>Source code related to controlling the filter band and antenna switches resides in e31x_radio_ctrl_impl.cpp. The methods set the switches depending on the state of transmit and receive streams.</p>
<p>The following sections provide switch setting tables for antenna and filter selection for frontends A &amp; B receive and transmit paths. For further details refer to the schematics.</p>
<h3><a class="anchor" id="e31x_dboard_e310_frontend_a_switches"></a>
Frontend Side A Filter and Antenna Switches</h3>
<p><em>Note: X = don't care, T = If full duplex, set bits according to transmit table, otherwise don't care. Filter range A  B will be selected if A &lt;= freq &lt; B.</em></p>
<p><b>Receive</b> </p><table class="doxtable">
<tr>
<th align="center">RX Port </th><th align="center">RX Filter (MHz) </th><th align="center">VCTXRX2_V1,V2 </th><th align="center">VCRX2_V1,V2 </th><th align="center">RX2_BANDSEL[2:0] </th><th align="center">RX2B_BANDSEL[1:0] </th><th align="center">RX2C_BANDSEL[1:0]  </th></tr>
<tr>
<td align="center">TRX-A </td><td align="center">&lt; 450 </td><td align="center">01 </td><td align="center">10 </td><td align="center">101 </td><td align="center">XX </td><td align="center">01 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">450  700 </td><td align="center">01 </td><td align="center">10 </td><td align="center">011 </td><td align="center">XX </td><td align="center">11 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">700  1200 </td><td align="center">01 </td><td align="center">10 </td><td align="center">001 </td><td align="center">XX </td><td align="center">10 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">1200  1800 </td><td align="center">01 </td><td align="center">10 </td><td align="center">000 </td><td align="center">01 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">1800  2350 </td><td align="center">01 </td><td align="center">10 </td><td align="center">010 </td><td align="center">11 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">2350  2600 </td><td align="center">01 </td><td align="center">10 </td><td align="center">100 </td><td align="center">10 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">2600  6000 </td><td align="center">01 </td><td align="center">01 </td><td align="center">XXX </td><td align="center">XX </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">70  450 </td><td align="center">TT </td><td align="center">01 </td><td align="center">101 </td><td align="center">XX </td><td align="center">01 </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">450  700 </td><td align="center">TT </td><td align="center">01 </td><td align="center">011 </td><td align="center">XX </td><td align="center">11 </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">700  1200 </td><td align="center">TT </td><td align="center">01 </td><td align="center">001 </td><td align="center">XX </td><td align="center">10 </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">1200  1800 </td><td align="center">TT </td><td align="center">01 </td><td align="center">000 </td><td align="center">01 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">1800  2350 </td><td align="center">TT </td><td align="center">01 </td><td align="center">010 </td><td align="center">11 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">2350  2600 </td><td align="center">TT </td><td align="center">01 </td><td align="center">100 </td><td align="center">10 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-A </td><td align="center">&gt;= 2600 </td><td align="center">TT </td><td align="center">10 </td><td align="center">XXX </td><td align="center">XX </td><td align="center">XX </td></tr>
</table>
<p><b>Transmit</b> </p><table class="doxtable">
<tr>
<th align="center">TX Port </th><th align="center">TX Filter (MHz) </th><th align="center">VCTXRX2_V1,V2 </th><th align="center">TX_ENABLE2A,2B </th><th align="center">TX_BANDSEL[2:0]  </th></tr>
<tr>
<td align="center">TRX-A </td><td align="center">&lt; 117.7 </td><td align="center">10 </td><td align="center">01 </td><td align="center">111 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">117.7  178.2 </td><td align="center">10 </td><td align="center">01 </td><td align="center">110 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">178.2  284.3 </td><td align="center">10 </td><td align="center">01 </td><td align="center">101 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">284.3  453.7 </td><td align="center">10 </td><td align="center">01 </td><td align="center">100 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">453.7  723.8 </td><td align="center">10 </td><td align="center">01 </td><td align="center">011 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">723.8  1154.9 </td><td align="center">10 </td><td align="center">01 </td><td align="center">010 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">1154.9  1842.6 </td><td align="center">10 </td><td align="center">01 </td><td align="center">001 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">1842.6  2940.0 </td><td align="center">10 </td><td align="center">01 </td><td align="center">000 </td></tr>
<tr>
<td align="center">TRX-A </td><td align="center">&gt;= 2940.0 </td><td align="center">11 </td><td align="center">10 </td><td align="center">XXX </td></tr>
</table>
<p><em>Note: Although the transmit filters are low pass, this table describes UHD's tuning range for selecting each filter path. The table also includes the required transmit enable state.</em></p>
<h3><a class="anchor" id="e31x_dboard_e310_frontend_b_switches"></a>
Frontend Side B Filter and Antenna Switches</h3>
<p><em>Note: X = don't care, T = If full duplex, set bits according to transmit table, otherwise don't care. Filter range A  B will be selected if A &lt;= freq &lt; B.</em></p>
<p><b>Receive</b> </p><table class="doxtable">
<tr>
<th align="center">RX Port </th><th align="center">RX Filter (MHz) </th><th align="center">VCTXRX1_V1,V2 </th><th align="center">VCRX1_V1,V2 </th><th align="center">RX1_BANDSEL[2:0] </th><th align="center">RX1B_BANDSEL[1:0] </th><th align="center">RX1C_BANDSEL[1:0]  </th></tr>
<tr>
<td align="center">TRX-B </td><td align="center">&lt; 450 </td><td align="center">10 </td><td align="center">01 </td><td align="center">100 </td><td align="center">XX </td><td align="center">10 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">450  700 </td><td align="center">10 </td><td align="center">01 </td><td align="center">010 </td><td align="center">XX </td><td align="center">11 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">700  1200 </td><td align="center">10 </td><td align="center">01 </td><td align="center">000 </td><td align="center">XX </td><td align="center">01 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">1200  1800 </td><td align="center">10 </td><td align="center">01 </td><td align="center">001 </td><td align="center">10 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">1800  2350 </td><td align="center">10 </td><td align="center">01 </td><td align="center">011 </td><td align="center">11 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">2350  2600 </td><td align="center">10 </td><td align="center">01 </td><td align="center">101 </td><td align="center">01 </td><td align="center">XX </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">2600  6000 </td><td align="center">10 </td><td align="center">10 </td><td align="center">XXX </td><td align="center">XX </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">70  450 </td><td align="center">TT </td><td align="center">01 </td><td align="center">100 </td><td align="center">XX </td><td align="center">10 </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">450  700 </td><td align="center">TT </td><td align="center">01 </td><td align="center">010 </td><td align="center">XX </td><td align="center">11 </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">700  1200 </td><td align="center">TT </td><td align="center">01 </td><td align="center">000 </td><td align="center">XX </td><td align="center">01 </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">1200  1800 </td><td align="center">TT </td><td align="center">01 </td><td align="center">001 </td><td align="center">10 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">1800  2350 </td><td align="center">TT </td><td align="center">01 </td><td align="center">011 </td><td align="center">11 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">2350  2600 </td><td align="center">TT </td><td align="center">01 </td><td align="center">101 </td><td align="center">01 </td><td align="center">XX </td></tr>
<tr>
<td align="center">RX2-B </td><td align="center">&gt;= 2600 </td><td align="center">TT </td><td align="center">10 </td><td align="center">XXX </td><td align="center">XX </td><td align="center">XX </td></tr>
</table>
<p><b>Transmit</b> </p><table class="doxtable">
<tr>
<th align="center">TX Port </th><th align="center">TX Filter (MHz) </th><th align="center">VCTXRX1_V1,V2 </th><th align="center">TX_ENABLE1A,1B </th><th align="center">TX1_BANDSEL[2:0]  </th></tr>
<tr>
<td align="center">TRX-B </td><td align="center">&lt; 117.7 </td><td align="center">00 </td><td align="center">01 </td><td align="center">111 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">117.7  178.2 </td><td align="center">00 </td><td align="center">01 </td><td align="center">110 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">178.2  284.3 </td><td align="center">00 </td><td align="center">01 </td><td align="center">101 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">284.3  453.7 </td><td align="center">00 </td><td align="center">01 </td><td align="center">100 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">453.7  723.8 </td><td align="center">00 </td><td align="center">01 </td><td align="center">011 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">723.8  1154.9 </td><td align="center">00 </td><td align="center">01 </td><td align="center">010 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">1154.9  1842.6 </td><td align="center">00 </td><td align="center">01 </td><td align="center">001 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">1842.6  2940.0 </td><td align="center">00 </td><td align="center">01 </td><td align="center">000 </td></tr>
<tr>
<td align="center">TRX-B </td><td align="center">&gt;= 2940.0 </td><td align="center">11 </td><td align="center">10 </td><td align="center">XXX </td></tr>
</table>
<p><em>Note: Although the transmit filters are low pass, the following table describes UHD's tuning range for selecting each filter path. The table also includes the required transmit enable states.</em></p>
<h1><a class="anchor" id="e320_neon"></a>
E320-specific Features</h1>
<h2><a class="anchor" id="e320_panels"></a>
Front and Rear Panel</h2>
<p>Like the USRP X300 and N310 series, E320 has connectors on both the front and back panel. The back panel holds the power connector, all network connections, USB connections for serial console (see <a class="el" href="page_usrp_e3xx.html#e3xx_getting_started_serial">Serial connection</a>), JTAG and peripherals, and front-panel GPIO.</p>
<p>The front panel is used for all RF connections, SMA connectors for GPS antenna input, 10 MHz external clock reference.</p>
<p>The connectors are labeled RF A and RF B and are powered by the two channels of AD9361 RFIC.</p>
<h2><a class="anchor" id="e320_gpio"></a>
Front Panel GPIO</h2>
<h3>Front Panel GPIO Connections</h3>
<table class="doxtable">
<tr>
<th>GPIO </th><th>Mini HDMI (Type C) </th><th>HDMI (Type A)  </th></tr>
<tr>
<td>Data[0] </td><td>Data 0+ - Pin 8 </td><td>Pin 7 </td></tr>
<tr>
<td>Data[1] </td><td>Data 0- - Pin 9 </td><td>Pin 9 </td></tr>
<tr>
<td>Data[2] </td><td>Clock 0+ - Pin 11 </td><td>Pin 10 </td></tr>
<tr>
<td>Data[3] </td><td>Clock 0- - Pin 12 </td><td>Pin 12 </td></tr>
<tr>
<td>Data[4] </td><td>CEC - Pin 14 </td><td>Pin 13 </td></tr>
<tr>
<td>Data[5] </td><td>SCL - Pin 15 </td><td>Pin 15 </td></tr>
<tr>
<td>Data[6] </td><td>SDA - Pin 16 </td><td>Pin 16 </td></tr>
<tr>
<td>Data[7] </td><td>Utility - Pin 17 </td><td>Pin 14 </td></tr>
</table>
<h2><a class="anchor" id="e320_eeprom_flags"></a>
EEPROM flags</h2>
<p>EEPROM flags can be set with </p><pre class="fragment">$ eeprom-set-flags 0xFLAGS
</pre><p>where FLAGS is the hex number that you can construct with the following table of bits:</p>
<table class="doxtable">
<tr>
<th>Bit </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>Auto-boot (1=on) </td></tr>
<tr>
<td>1 </td><td>Fan (1=present) </td></tr>
<tr>
<td>2 </td><td>TPM (0=present) </td></tr>
<tr>
<td>3 </td><td>Enclosure (1=present) </td></tr>
</table>
<p>For example, to set your device to auto-boot, with TPM, and with fans, the flag value is 0x5, so </p><pre class="fragment">$ eeprom-set-flags 0x5
</pre><h1><a class="anchor" id="e3xx_regmap"></a>
E3XX FPGA Register Map</h1>
<p>The following tables describe how FPGA registers are mapped into the PS. This is for reference only, most users will not even have to know about this table.</p>
<table class="doxtable">
<tr>
<th>AXI Slave </th><th>Address Range </th><th>UIO Label </th><th>Description  </th></tr>
<tr>
<td>Slave 0 </td><td>4000_0000 - 4000_3fff </td><td>- </td><td>Ethernet DMA SFP (only for E320) </td></tr>
<tr>
<td>Slave 1 </td><td>4000_4000 - 4000_4fff </td><td>misc-enet-regs </td><td>Ethernet registers SFP (only for E320) </td></tr>
<tr>
<td>Slave 2 </td><td>4001_0000 - 4001_3fff </td><td>mboard-regs </td><td>Motherboard control </td></tr>
<tr>
<td>Slave 3 </td><td>4001_4000 - 4001_41ff </td><td>dboard-regs </td><td>Daughterboard control </td></tr>
</table>
<a class="anchor" id="e3xx_multi_row"></a>
<table class="doxtable">
<caption>E3XX Register Map</caption>
<tr>
<th>AXI Slave </th><th>Module </th><th>Address </th><th>Name </th><th>Read/Write </th><th>Description </th></tr>
<tr>
<td rowspan="1">Slave 0 </td><td rowspan="1">axi_eth_dma </td><td>4000_0000 - 4000_4fff </td><td>Ethernet DMA </td><td>RW </td><td>See Linux Driver (only on E320) </td></tr>
<tr>
<td rowspan="44">Slave 1 </td><td rowspan="7">e320_mgt_io_core </td><td>4000_4000 </td><td>PORT_INFO </td><td>RO </td><td>SFP port information </td></tr>
<tr>
<td>[31:24] </td><td>COMPAT_NUM </td><td>RO </td><td>- </td></tr>
<tr>
<td>[23:18] </td><td>6'h0 </td><td>RO </td><td>- </td></tr>
<tr>
<td>[17] </td><td>activity </td><td>RO </td><td>- </td></tr>
<tr>
<td>[16] </td><td>link_up </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:8] </td><td>mgt_protocol </td><td>RO </td><td>0 - None, 1 - 1G, 2 - XG, 3 - Aurora </td></tr>
<tr>
<td>[7:0] </td><td>PORTNUM </td><td>RO </td><td>- </td></tr>
<tr>
<td rowspan="8">e320_mgt_io_core </td><td>4000_4004 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td>Control 10gE and Aurora mac </td></tr>
<tr>
<td>[0] </td><td>ctrl_tx_enable (PROTOCOL = "10GbE")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[0] </td><td>bist_checker_en (PROTOCOL = "Aurora")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[1] </td><td>bist_gen_en </td><td>RW </td><td>- </td></tr>
<tr>
<td>[2] </td><td>bist_loopback_en</td><td>RW </td><td>- </td></tr>
<tr>
<td>[8:3] </td><td>bist_gen_rate </td><td>RW </td><td>- </td></tr>
<tr>
<td>[9] </td><td>phy_areset </td><td>RW </td><td>- </td></tr>
<tr>
<td>[10] </td><td>mac_clear </td><td>RW </td><td>- </td></tr>
<tr>
<td>e320_mgt_io_core </td><td>4000_4008 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td>Phy reset control </td></tr>
<tr>
<td rowspan="3">e320_mgt_io_core </td><td>4000_400C </td><td>MAC_LED_CTL </td><td>RW </td><td>Used by ethtool to indicate port </td></tr>
<tr>
<td>[1] </td><td>identify_enable </td><td>RW </td><td>- </td></tr>
<tr>
<td>[0] </td><td>identify_value </td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">mdio_master </td><td>4000_4010 </td><td>MDIO_DATA </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4014 </td><td>MDIO_ADDR </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4018 </td><td>MDIO_OP </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_401C </td><td>MDIO_CTRL_STATUS</td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">e320_mgt_io_core </td><td>4000_4020 </td><td>AURORA_OVERUNS </td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4024 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4028 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_402C </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td>- </td></tr>
<tr>
<td rowspan="4">eth_switch </td><td>4000_5000 </td><td>MAC_LSB </td><td>RW </td><td>Device MAC LSB </td></tr>
<tr>
<td>4000_5004 </td><td>MAC_MSB </td><td>RW </td><td>Device MAC MSB </td></tr>
<tr>
<td>4000_6000 </td><td>IP </td><td>RW </td><td>Device IP </td></tr>
<tr>
<td>4000_6004 </td><td>PORT1, PORT0 </td><td>RW </td><td>Device UDP port </td></tr>
<tr>
<td rowspan="2">eth_dispatch </td><td>4000_6008 </td><td>[1] ndest, [0] bcast</td><td>RW </td><td>Enable Crossover </td></tr>
<tr>
<td>4000_600c </td><td>[1] my_icmp_type, [0] my_icmp_code</td><td>- </td></tr>
<tr>
<td rowspan="5">eth_switch </td><td>4000_6010 </td><td>BRIDGE_MAC_LSB </td><td></td><td>Bridge SFP ports in ARM </td></tr>
<tr>
<td>4000_6014 </td><td>BRIDGE_MAC_MSB </td><td></td><td>- </td></tr>
<tr>
<td>4000_6018 </td><td>BRIDGE_IP </td><td></td><td>- </td></tr>
<tr>
<td>4000_601c </td><td>BRIDGE_PORT1, BRIDGE_PORT0</td><td></td><td>- </td></tr>
<tr>
<td>4000_6020 </td><td>BRIDGE_EN </td><td></td><td>- </td></tr>
<tr>
<td rowspan="6">chdr_eth_framer </td><td>4000_6108 onwards </td><td>LOCAL_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 256 SIDs </td></tr>
<tr>
<td>4000_6208 onwards </td><td>LOCAL_DST_UDP_MAC_MSB</td><td>W </td><td>Destination MAC for outgoing packets (MSB) </td></tr>
<tr>
<td>4000_6308 onwards </td><td>LOCAL_DST_MAC_LSB</td><td>W </td><td>Destination MAC for outgoing packets (LSB) </td></tr>
<tr>
<td>4000_7000 onwards </td><td>REMOTE_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 16 local addrs </td></tr>
<tr>
<td>4000_7400 onwards </td><td>REMOTE_DST_UDP_MAC_HI</td><td>W </td><td>Destination MAC (MSB) </td></tr>
<tr>
<td>4000_7800 onwards </td><td>REMOTE_DST_MAC_LO</td><td>W </td><td><p class="starttd">Destination MAC (LSB)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="32">Slave 2 </td><td rowspan="27">e320_core </td><td>4001_0000 </td><td>COMPAT_NUM </td><td>R </td><td>FPGA Compat Number </td></tr>
<tr>
<td>[31:16] </td><td>Major </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:0] </td><td>Minor </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0004 </td><td>DATESTAMP </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0008 </td><td>GIT_HASH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_000C </td><td>SCRATCH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0010 </td><td>NUM_CE </td><td>RO </td><td>Number of Computation Engines (RFNoC Blocks) </td></tr>
<tr>
<td>4001_0014 </td><td>NUM_IO_CE </td><td>RO </td><td>Number of fixed IO CEs - Radios + DMA Fifo </td></tr>
<tr>
<td>4001_0018 </td><td>CLOCK_CTRL </td><td></td><td>- </td></tr>
<tr>
<td>[0] </td><td>pps select (internal 10 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the internal PPS from GPSDO </td></tr>
<tr>
<td>[1] </td><td>pps select (external 10 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the external PPS. </td></tr>
<tr>
<td>[2] </td><td>refclk_select (internal/external 10 MHz)</td><td>RW</td><td>refclk_select=0 for internal (GPSDO) 10 MHz, refclk_sel=1 for external 10 MHz. </td></tr>
<tr>
<td>4001_001C </td><td>XADC_READBACK </td><td>RO </td><td>- </td></tr>
<tr>
<td>[11:0] </td><td>FPGA temperature</td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0020 </td><td>BUS_CLK_RATE </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0024 </td><td>BUS_CLK_COUNT </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0028 </td><td>SFP_PORT_INFO </td><td>RO </td><td>Same as port_info register 0x4000_4000 </td></tr>
<tr>
<td>4001_002C </td><td>FP_GPIO_CTRL </td><td>RW </td><td>- </td></tr>
<tr>
<td>4001_0030 </td><td>FP_GPIO_MASTER </td><td>RW </td><td>- </td></tr>
<tr>
<td>4001_0034 </td><td>FP_GPIO_RADIO_SRC </td><td>RW </td><td>- </td></tr>
<tr>
<td>4001_0038 </td><td>GPS_CTRL </td><td>RW </td><td>- </td></tr>
<tr>
<td>[0] </td><td>GPS_PWR_EN </td><td>RW </td><td>Power on GPSDO </td></tr>
<tr>
<td>[1] </td><td>GPS_RST_N </td><td>RW </td><td>- </td></tr>
<tr>
<td>[2] </td><td>GPS_INITSURV_N </td><td>RW </td><td>- </td></tr>
<tr>
<td>4001_003C </td><td>GPS_STATUS </td><td>RO </td><td>GPSDO Status </td></tr>
<tr>
<td>[0] </td><td>GPS_LOCK </td><td>RO </td><td>Returns 1 if GPSDO is locked </td></tr>
<tr>
<td>[1] </td><td>GPS_ALARM </td><td>RO </td><td>- </td></tr>
<tr>
<td>[2] </td><td>GPS_PHASELOCK </td><td>RO </td><td>- </td></tr>
<tr>
<td>[3] </td><td>GPS_SURVEY </td><td>RO </td><td>- </td></tr>
<tr>
<td>[4] </td><td>GPS_WARMUP </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0040 </td><td>DBOARD_CTRL </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0044 </td><td>DBOARD_STATUS </td><td>RO </td><td><p class="starttd">-</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="5">axi_crossbar </td><td>4001_1010 </td><td>XBAR_VERSION </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1014 </td><td>XBAR_NUM_PORTS </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1018 </td><td>LOCAL_ADDR </td><td>RW </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1020 </td><td>remote_offset </td><td>WO </td><td>XBAR settings reg </td></tr>
<tr>
<td>4001_1420 </td><td>local_offset </td><td>WO </td><td><p class="starttd">XBAR settings reg</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="6">Slave 4 </td><td>4001_4000</td><td>4001_41FF</td><td>Daughterboard Registers</td><td>- </td><td>Don't exist now. TBD </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
