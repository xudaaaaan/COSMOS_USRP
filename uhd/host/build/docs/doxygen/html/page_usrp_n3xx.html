<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: USRP N3xx Series</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.15.0.main-0-ee6805b3</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_usrp_n3xx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">USRP N3xx Series </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#n3xx_feature_list">Comparative features list</a><ul><li class="level2"><a href="#n3xx_feature_list_mg">N310/N300 4-channel/2-channel Transceiver</a></li>
<li class="level2"><a href="#n3xx_feature_list_rh">N320/N321 2-channel Transceiver</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_overview">Overview</a><ul><li class="level2"><a href="#n3xx_zynq">The Zynq CPU/FPGA and host operating system</a></li>
<li class="level2"><a href="#n3xx_micro">The STM32 microcontroller</a></li>
<li class="level2"><a href="#n3xx_sdcard">The SD card</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_getting_started">Getting started</a><ul><li class="level2"><a href="#n3xx_getting_started_assembling">Assembling the N3XX</a></li>
<li class="level2"><a href="#n3xx_getting_started_fs_update">Updating the file system</a></li>
<li class="level2"><a href="#n3xx_getting_started_serial">Serial connection</a><ul><li class="level3"><a href="#n3xx_getting_started_serial_micro">Connecting to the microcontroller</a></li>
</ul>
</li>
<li class="level2"><a href="#n3xx_getting_started_ssh">SSH connection</a></li>
<li class="level2"><a href="#n3xx_getting_started_connectivity">Network Connectivity</a></li>
<li class="level2"><a href="#n3xx_getting_started_security">Security-related settings</a></li>
<li class="level2"><a href="#n3xx_getting_started_fpga_update">Updating the FPGA</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_usage">Using an N3XX USRP from UHD</a><ul><li class="level2"><a href="#n3xx_usage_device_args">Device arguments</a></li>
<li class="level2"><a href="#n3xx_usage_init">Device Initialization</a></li>
<li class="level2"><a href="#n3xx_usage_subdevspec">Subdev Specifications</a></li>
<li class="level2"><a href="#n3xx_usage_sensors">The sensor API</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_rasm">Remote Management</a><ul><li class="level2"><a href="#n3xx_rasm_mender">Mender: Remote update capability</a></li>
<li class="level2"><a href="#n3xx_rasm_salt">Salt: Remote configuration management and execution</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_synchronization">Clock/Time Synchronization</a><ul><li class="level2"><a href="#n3xx_synchronization_internal">Internal references</a></li>
<li class="level2"><a href="#n3xx_synchronization_external">External references</a></li>
<li class="level2"><a href="#n3xx_synchronization_whiterabbit">White Rabbit</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_troubleshooting">Troubleshooting</a><ul><li class="level2"><a href="#n3xx_troubleshooting_seqerrs">Errors while streaming</a></li>
<li class="level2"><a href="#n3xx_troubleshooting_bist">Built-in Self-Test (BiST)</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_theory_of_ops">Theory of Operation</a></li>
<li class="level1"><a href="#n3xx_fsbuild">Building custom filesystems and SD card images</a><ul><li class="level2"><a href="#n3xx_fsbuild_docker">Using Docker to build filesystems</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_software_dev">Modifying and compiling UHD and MPM for the N3XX</a><ul><li class="level2"><a href="#n3xx_software_dev_mpm_native">Compiling MPM natively</a></li>
<li class="level2"><a href="#n3xx_software_dev_sdk">Obtaining an SDK</a></li>
<li class="level2"><a href="#n3xx_software_dev_sdkusage">SDK Usage</a><ul><li class="level3"><a href="#n3xx_software_dev_uhd">Building UHD</a></li>
<li class="level3"><a href="#n3xx_software_dev_gr">Building GNU Radio</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#n3xx_mg">N310-specific Features</a><ul><li class="level2"><a href="#n3xx_mg_panels">Front and Rear Panel</a></li>
<li class="level2"><a href="#n3xx_mg_initialization">Device Initialization (Fast and Slow)</a></li>
<li class="level2"><a href="#n3xx_mg_calibrations">RF Calibrations</a></li>
<li class="level2"><a href="#n3xx_mg_external_lo">External LOs</a></li>
<li class="level2"><a href="#n3xx_mg_eeprom">Storing user data in the EEPROM</a></li>
<li class="level2"><a href="#n3xx_mg_revs">Module and Motherboard/Daughterboard Revisions</a></li>
<li class="level2"><a href="#n3xx_mg_regmap">FPGA Register Map</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_rh">N32x-specific Features</a><ul><li class="level2"><a href="#n3xx_rh_panels">Front and Rear Panel</a></li>
<li class="level2"><a href="#n3xx_rh_initialization">Device Initialization (Fast and Slow)</a></li>
<li class="level2"><a href="#n3xx_rh_calibrations">RF Calibrations</a></li>
<li class="level2"><a href="#n3xx_rh_external_lo">External LOs</a></li>
<li class="level2"><a href="#n3xx_rh_lo_sharing">N321 LO Distribution Board</a></li>
<li class="level2"><a href="#n3xx_rh_lo_chaining">N320/N321 LO Sharing</a></li>
<li class="level2"><a href="#n3xx_rh_sfp_protocols">SFP+ and QSFP+ protocols</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="n3xx_feature_list"></a>
Comparative features list</h1>
<ul>
<li>Hardware Capabilities:<ul>
<li>Dual SFP+ Transceivers (can be used with 1 GigE, 10 GigE, and Aurora)</li>
<li>External PPS input &amp; output</li>
<li>External 10 MHz input &amp; output (20 MHz and 25 MHz inputs also supported)</li>
<li>External White Rabbit time/frequency reference input support</li>
<li>Internal 25 MHz reference clock</li>
<li>Internal GPSDO for timing, location, and 20 MHz reference clock + PPS</li>
<li>External GPIO Connector with UHD API control</li>
<li>External USB Connection for built-in JTAG debugger and serial console</li>
<li>Xilinx Zynq SoC with dual-core ARM Cortex A9 (Speedgrade 2) and Kintex-7 FPGA (XC7Z100 or XC7Z035 depending on variant)</li>
</ul>
</li>
<li>Software Capabilities:<ul>
<li>Full Linux system running on the ARM core</li>
<li>Runs MPM (see also <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>)</li>
</ul>
</li>
<li>FPGA Capabilities:<ul>
<li>Timed commands in FPGA</li>
<li>Timed sampling in FPGA</li>
<li>RFNoC capability</li>
</ul>
</li>
</ul>
<p>The N3XX series of USRPs is designed as a platform. The following USRPs are variants of the N3XX series:</p>
<h2><a class="anchor" id="n3xx_feature_list_mg"></a>
N310/N300 4-channel/2-channel Transceiver</h2>
<div class="image">
<img src="N310isoExplode.png" alt="N310isoExplode.png"/>
<div class="caption">
N310 Exploded View</div></div>
<ul>
<li>Supported master clock rates: 122.88 MHz, 125 MHz, 153.6 MHz</li>
<li>Tuning range: 10 MHz to 6 GHz (below 300 MHz, additional LOs and mixer stages are used to shift the signal into the frequency range of the AD9371)</li>
<li>Support for external LOs</li>
<li>4 RX DDC chains in FPGA (2 for N300)</li>
<li>4 TX DUC chain in FPGA (2 for N300)</li>
<li>2 SFP+ connectors</li>
</ul>
<p>The N310 is a 4-channel transmitter/receiver based on the AD9371 transceiver IC. It has two daughterboards with one AD9371 each; every daughterboard provides two RF channels. Note that the product code "N310" refers to the module consisting of mother- and daughterboard, the daughterboard itself is referred to by its codename, "Magnesium".</p>
<p>The N300 is a subset of the N310. It has 2 TX/RX channels (on a single daughterboard; the daughterboard itself is the same as the N310) and a smaller FPGA (XCZ035). Also, it does not have connectors for external LOs.</p>
<h2><a class="anchor" id="n3xx_feature_list_rh"></a>
N320/N321 2-channel Transceiver</h2>
<ul>
<li>Supported master clock rates: 200 MHz, 245.76 MHz, 250 MHz</li>
<li>Tuning range: 1 MHz to 6 GHz (below 450 MHz, an additional LO and mixer stage is used to shift the signal into the range of the main LO stage)</li>
<li>Support for external LOs</li>
<li>2 RX DDC chains in FPGA</li>
<li>2 TX DUC chain in FPGA</li>
<li>LO sharing between multiple devices (N321 only)</li>
<li>2 SFP+ connectors + 1 QSFP+ connector</li>
</ul>
<p>The N320 is a 2-channel transmitter/receiver using discrete components instead of an RFIC. It has two daughterboards, each has one ADC/DAC and provides one RF channel.</p>
<p>The difference between the N320 and the N321 is in its LO sharing capability. The N320 has a single input for the TX and RX LOs, respectively. The N321 also has the ability to export its LO up to four times, making it possible to share LOs between a large number of N321 devices without having to provide an external, separate LO source. Due to number of connectors required to provide the large number of LO outputs, the N321 does not have a front-panel GPIO connector.</p>
<p>The N320 has a higher maximum analog bandwidth than the N310. It can provide rates up to 250 Msps, resulting in a usable analog bandwidth of up to 200 MHz. In order to better use the high available rates, the N320/N321 devices have an additional QSFP+ connector on the back panel which can be used for streaming data to and from the radios. In order to facilitate the higher bandwidth, UHD uses a technology called <a class="el" href="page_dpdk.html">Data Plane Development Kit (DPDK)</a>. See the DPDK page for details on how it can improve streaming, and how to use it.</p>
<h1><a class="anchor" id="n3xx_overview"></a>
Overview</h1>
<h2><a class="anchor" id="n3xx_zynq"></a>
The Zynq CPU/FPGA and host operating system</h2>
<p>The main CPU of the N310 is a Xilinx Zynq SoC XC7Z100 (exception: The N300). It is both a dual-core ARM Cortex A9 CPU and Kintex-7 FPGA on a single die. The CPU is clocked at 800 MHz (speedgrade 2).</p>
<p>The programmable logic (PL, or FPGA) section of the SoC is responsible for handling all sampling data, the 10 GigE network connections, and any other high-speed utility such as custom RFNoC logic. The processing system (PS, or CPU) is running a custom-build OpenEmbedded-based Linux operating system. The OS is responsible for all the device and peripheral management, such as running MPM, configuring the network interfaces, running local UHD sessions, etc.</p>
<p>It is possible to connect to the host OS either via SSH or serial console (see sections <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_ssh">SSH connection</a> and <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>, respectively).</p>
<h2><a class="anchor" id="n3xx_micro"></a>
The STM32 microcontroller</h2>
<p>The STM32 microcontroller controls various low-level features of the N3xx series motherboard: It controls the power sequencing, reads out fan speeds and some of the temperature sensors. It is connected to the Zynq via an I2C bus.</p>
<p>It is possible to log into the STM32 using the serial interface (see <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial_micro">Connecting to the microcontroller</a>). This will allow certain low-level controls, such as remote power cycling should the CPU have become unresponsive for whatever reason.</p>
<h2><a class="anchor" id="n3xx_sdcard"></a>
The SD card</h2>
<p>The N3XX series uses a micro SD card as its main storage. The entire root file system (Linux kernel, libraries) and any user data are stored on this SD card.</p>
<p>The SD card is partitioned into four partitions:</p>
<ol type="1">
<li>Boot partition (contains the bootloader). This partition usually does not require touching.</li>
<li>A data partition, mounted in /data. This is the only partition that is not erased during file system updates.</li>
</ol>
<ol type="1">
<li>Two identical system partitions (root file systems). These contain the operating system and the home directory (anything mounted under / that is not the data or boot partition). The reason there are two of these is to enable remote updates: An update running on one partition can update the other one without any effect to the currently running system. Note that the system partitions are erased during updates and are thus unsuitable for permanently storing information.</li>
</ol>
<p>Note: It is possible to access the currently inactive root file system by mounting it. After logging into the device using serial console or SSH (see the following two sections), run the following commands: </p><pre class="fragment">$ mkdir temp
$ mount /dev/mmcblk0p3 temp
$ ls temp # You are now accessing the idle partition:
bin   data  etc   lib         media  proc  sbin  tmp    usr
boot  dev   home  lost+found  mnt    run   sys   uboot  var
</pre><p>The device node in the mount command will likely differ, depending on which partition is currently already mounted.</p>
<h1><a class="anchor" id="n3xx_getting_started"></a>
Getting started</h1>
<p>This will run you through the first steps relevant to getting your USRP N3XX series up and running.</p>
<h2><a class="anchor" id="n3xx_getting_started_assembling"></a>
Assembling the N3XX</h2>
<p>Unlike the X300 or N200 series, there is no assembly of daughterboards required. Members of the N3XX product family, such as the N310, ship with daughterboards pre-installed.</p>
<p>Checklist:</p><ul>
<li>Connect power and network</li>
<li>Read security settings</li>
<li>Connect clocking (if required)</li>
<li>Connect external LOs (if required)</li>
</ul>
<h2><a class="anchor" id="n3xx_getting_started_fs_update"></a>
Updating the file system</h2>
<p>Before doing any major work with a newly acquired USRP N300/N310, it is recommended to update the file system. Updating the filesystem can be accomplished directly on the N300/N310 by using Mender or externally by manually writing an image onto a micro SD card and inserting it. While manual updating is faster, Mender requires no direct physical access to the device. For details on using Mender, see Section <a class="el" href="page_usrp_n3xx.html#n3xx_rasm_mender">Mender: Remote update capability</a> .</p>
<p>Manual updating is simply loading an image on the micro SD card. The first step in that process is to obtain an image.</p>
<p>To obtain the default micro SD card image for a specific version of UHD, install that version of UHD (3.11.0.1 or later) on a host system with Internet access and run: </p><pre class="fragment">$ uhd_images_downloader -t n3xx_common_sdimg_default
</pre><p>The image will be downloaded to <code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_n3xx_fs.sdimg</code>, where <code>&lt;UHD_INSTALL_DIR&gt;</code> is the UHD installation directory.</p>
<p>To load an image onto the micro SD card, connect the card to the host and run: </p><pre class="fragment">$ sudo dd if=&lt;YOUR_IMAGE&gt; of=/dev/&lt;YOUR_SD_CARD&gt; bs=1M
</pre><p>The <code>&lt;YOUR_IMAGE&gt;</code> is the path to the micro SD card image (i.e.<code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_n3xx_fs.sdimg</code>).</p>
<p>The <code>&lt;YOUR_SD_CARD&gt;</code> device node depends on your operating system and which other devices are plugged in. Typical values are <code>sdb</code> or <code>mmcblk0</code>.<br />
 CAUTION: Operating on the wrong device can cause damage to that device.</p>
<p>The micro SD card used can be the original SD card shipped with the device or another one that is at least 16 GB in size.</p>
<p>Insert the updated micro SD card and power on the device.</p>
<h2><a class="anchor" id="n3xx_getting_started_serial"></a>
Serial connection</h2>
<p>It is possible to gain root access to the device using a serial terminal emulator. Most Linux, OSX, or other Unix flavours have a tool called 'screen' which can be used for this purpose, by running the following command: </p><pre class="fragment">$ sudo screen /dev/ttyUSB2 115200
</pre><p>In this command, we prepend 'sudo' to elevate user privileges (by default, accessing serial ports is not available to regular users), we specify the device node (in this case, <code>/dev/ttyUSB2</code>), and the baud rate (115200).</p>
<p>The exact device node depends on your operating system's driver and other USB devices that might be already connected. Modern Linux systems offer alternatives to simply trying device nodes; instead, the OS might have a directory of symlinks under <code>/dev/serial/by-id</code>: </p><pre class="fragment">$ ls /dev/serial/by-id
usb-Digilent_Digilent_USB_Device_25163511FE00-if00-port0
usb-Digilent_Digilent_USB_Device_25163511FE00-if01-port0
usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if00-port0
usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if01-port0
</pre><p>Note: Exact names depend on the host operating system version and may differ.</p>
<p>Every N3XX series device connected to USB will by default show up as four different devices. The devices labeled "USB_to_UART_Bridge_Controller" are the devices that offer a serial prompt. The first (with the <code>if00</code> suffix) connects to Linux, whereas the second connects to the STM32 microcontroller. If you have multiple N3XX devices connect, you may have to try out multiple devices. In this case, to use this symlink instead of the raw device node address, modify the command above to: </p><pre class="fragment">$ sudo screen /dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if00-port0 115200
</pre><p>You should be presented with a shell prompt similar to the following: </p><pre class="fragment">root@ni-n3xx-311FE00:~#
</pre><p>On this prompt, you can enter any Linux command available. Using the default configuration, the serial console will also show all kernel log messages (unlike when using SSH, for example), and give access to the boot loader (U-boot prompt). This can be used to debug kernel or bootloader issues more efficiently than when logged in via SSH.</p>
<h3><a class="anchor" id="n3xx_getting_started_serial_micro"></a>
Connecting to the microcontroller</h3>
<p>The STM32 microcontroller (which controls the power sequencing, among other things) also has a serial console available. To connect to the microcontroller, use the other UART device. In the example above: </p><pre class="fragment">$ sudo screen /dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if01-port0 115200
</pre><p>It provides a very simple prompt. The command 'help' will list all available commands. A direct connection to the microcontroller can be used to hard-reset the device without physically accessing it (i.e., emulating a power button press) and other low-level diagnostics.</p>
<h2><a class="anchor" id="n3xx_getting_started_ssh"></a>
SSH connection</h2>
<p>The USRP N-Series devices have two network connections: The dual SFP ports, and an RJ-45 connector. The latter is by default configured by DHCP; by plugging it into into 1 Gigabit switch on a DHCP-capable network, it will get assigned an IP address and thus be accessible via ssh.</p>
<p>In case your network setup does not include a DHCP server, refer to the section <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>. A serial login can be used to assign an IP address manually.</p>
<p>After the device obtained an IP address you can log in from a Linux or OSX machine by typing: </p><pre class="fragment">$ ssh root@ni-n3xx-311FE00 # Replace with your actual device name!
</pre><p>Depending on your network setup, using a <code>.local</code> domain may work: </p><pre class="fragment">$ ssh root@ni-n3xx-311FE00.local
</pre><p>Of course, you can also connect to the IP address directly if you know it (or set it manually using the serial console).</p>
<p>Note: The device's hostname is derived from its serial number by default (<code>ni-n3xx-$SERIAL</code>). You can change the hostname by modifying the <code>/etc/hostname</code> file and rebooting.</p>
<p>On Microsoft Windows, the connection can be established using a tool such as Putty, by selecting a username of root without password.</p>
<p>Like with the serial console, you should be presented with a prompt like the following: </p><pre class="fragment">root@ni-n3xx-311FE00:~#
</pre><h2><a class="anchor" id="n3xx_getting_started_connectivity"></a>
Network Connectivity</h2>
<p>The RJ45 port (eth0) comes up with a default configuration of DHCP, that will request a network address from your DHCP server (if available on your network).</p>
<p>The SFP+ (sfp0, sfp1) ports are configured with static addresses 192.168.10.2/24 and 192.168.20.2/24, respectively. Their default MTU value is 8000. These settings are independent of the image type (HG vs. XG), i.e., the defaults are the same for 1 GigE and 10 GigE (unlike the X310!).</p>
<p>The configuration for the sfpX port is stored in /etc/systemd/network/sfpX.network.</p>
<p>For configuration please refer to the <a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">systemd-networkd manual pages</a></p>
<p>The factory settings are as follows: </p><pre class="fragment">eth0 (DHCP):

    [Match]
    Name=eth0

    [Network]
    DHCP=v4

    [DHCPv4]
    UseHostname=false

sfp0 (static):

    [Match]
    Name=sfp0

    [Network]
    Address=192.168.10.2/24

    [Link]
    MTUBytes=8000

sfp1 (static):

    [Match]
    Name=sfp1

    [Network]
    Address=192.168.20.2/24

    [Link]
    MTUBytes=8000
</pre><p>Additional notes on networking:</p>
<ul>
<li>Care needs to be taken when editing these files on the device, since vi / vim sometimes generates undo files (e.g. <code>/etc/systemd/network/sfp0.network~</code>), that systemd-networkd might accidentally pick up.</li>
<li>Temporarily setting the IP addresses or MTU sizes via <code>ifconfig</code> or other command line tools will only change the value until the next reboot or reload of the FPGA image.</li>
<li>If the MTU of the device and host computers differ, streaming issues can occur.</li>
</ul>
<h2><a class="anchor" id="n3xx_getting_started_security"></a>
Security-related settings</h2>
<p>The N3XX ships without a root password set. It is possible to ssh into the device by simply connecting as root, and thus gaining access to all subsystems. To set a password, run the command </p><pre class="fragment">$ passwd
</pre><p>on the device.</p>
<h2><a class="anchor" id="n3xx_getting_started_fpga_update"></a>
Updating the FPGA</h2>
<p>Updating the FPGA follows the same procedure as other USRPs. Use the <code>uhd_image_loader</code> command line utility to upload a new FPGA image onto the device.</p>
<p>A common reason to update the FPGA image is in the case of a UHD/FPGA compat number mismatch (for example, if UHD has been updated, and now expects a newer version of the FPGA than is on the device). In this case, simply run </p><pre class="fragment">$ uhd_images_downloader
</pre><p>to update the local cache of FPGA images. Then, run </p><pre class="fragment">$ uhd_image_loader --args type=n3xx,addr=ni-n3xx-311fe00
</pre><p>to update the FPGA using the default settings. If a custom FPGA image is targeted for uploading, use the <code>--fpga-path</code> command line argument. Run </p><pre class="fragment">$ uhd_image_loader --help
</pre><p>to see a full list of command line options. Note that updating the FPGA image will force a reload of the FPGA, which will temporarily take down the SFP network interfaces (and temporary settings, such as applied via <code>ifconfig</code> on the command line, will be lost).</p>
<h1><a class="anchor" id="n3xx_usage"></a>
Using an N3XX USRP from UHD</h1>
<p>Like any other USRP, all N3XX USRPs are controlled by the UHD software. To integrate a USRP N3XX into your C++ application, you would generate a UHD device in the same way you would for any other USRP:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;type=n3xx&quot;</span>);</div></div><!-- fragment --><p>For a list of which arguments can be passed into make(), see Section <a class="el" href="page_usrp_n3xx.html#n3xx_usage_device_args">Device arguments</a>.</p>
<h2><a class="anchor" id="n3xx_usage_device_args"></a>
Device arguments</h2>
<table class="doxtable">
<tr>
<th>Key </th><th>Description </th><th>Supported Devices </th><th>Example Value  </th></tr>
<tr>
<td>addr </td><td>IPv4 address of primary SFP+ port to connect to. </td><td>All N3xx </td><td>addr=192.168.30.2 </td></tr>
<tr>
<td>second_addr </td><td>IPv4 address of secondary SFP+ port to connect to. </td><td>All N3xx </td><td>second_addr=192.168.40.2 </td></tr>
<tr>
<td>mgmt_addr </td><td>IPv4 address or hostname which to connect the RPC client. Defaults to `addr'.</td><td>All N3xx </td><td>mgmt_addr=ni-sulfur-311FE00 (can also go to RJ45) </td></tr>
<tr>
<td>find_all </td><td>When using broadcast, find all devices, even if unreachable via CHDR. </td><td>All N3xx </td><td>find_all=1 </td></tr>
<tr>
<td>force_reinit </td><td>Force full reinitialization of all subsystems. Will increase init time. </td><td>N310 </td><td>force_reinit=1 </td></tr>
<tr>
<td>master_clock_rate </td><td>Master Clock Rate in Hz </td><td>N310 </td><td>master_clock_rate=125e6 </td></tr>
<tr>
<td>identify </td><td>Causes front-panel LEDs to blink. The duration is variable. </td><td>N310 </td><td>identify=5 (will blink for about 5 seconds) </td></tr>
<tr>
<td>serialize_init </td><td>Force serial initialization of daughterboards. </td><td>All N3xx </td><td>serialize_init=1 </td></tr>
<tr>
<td>skip_dram </td><td>Ignore DRAM FIFO block. Connect TX streamers straight into DUC or radio. </td><td>All N3xx </td><td>skip_dram=1 </td></tr>
<tr>
<td>skip_ddc </td><td>Ignore DDC block. Connect Rx streamers straight into radio. </td><td>All N3xx </td><td>skip_ddc=1 </td></tr>
<tr>
<td>skip_duc </td><td>Ignore DUC block. Connect Rx streamers or DRAM straight into radio. </td><td>All N3xx </td><td>skip_duc=1 </td></tr>
<tr>
<td>skip_init </td><td>Skip the initialization process for the device. </td><td>All N3xx </td><td>skip_init=1 </td></tr>
<tr>
<td>time_source </td><td>Specify the time (PPS) source. </td><td>All N3xx </td><td>time_source=internal </td></tr>
<tr>
<td>clock_source </td><td>Specify the reference clock source. </td><td>All N3xx </td><td>clock_source=internal </td></tr>
<tr>
<td>ref_clk_freq </td><td>Specify the external reference clock frequency, default is 10 MHz. </td><td>N310 </td><td>ref_clk_freq=20e6 </td></tr>
<tr>
<td>init_cals </td><td>Specify the bitmask for initial calibrations of the RFIC. </td><td>N310 </td><td>init_cals=BASIC </td></tr>
<tr>
<td>init_cals_timeout </td><td>Timeout for initial calibrations in milliseconds. </td><td>N310 </td><td>init_cals_timeout=45000 </td></tr>
<tr>
<td>discovery_port </td><td>Override default value for MPM discovery port. </td><td>All N3xx </td><td>discovery_port=49700 </td></tr>
<tr>
<td>rpc_port </td><td>Override default value for MPM RPC port. </td><td>All N3xx </td><td>rpc_port=49701 </td></tr>
<tr>
<td>tracking_cals </td><td>Specify the bitmask for tracking calibrations of the RFIC. </td><td>N310 </td><td>tracking_cals=ALL </td></tr>
<tr>
<td>rx_lo_source </td><td>Initialize the source for the RX LO. </td><td>N310 </td><td>rx_lo_source=external </td></tr>
<tr>
<td>tx_lo_source </td><td>Initialize the source for the TX LO. </td><td>N310 </td><td>tx_lo_source=external </td></tr>
<tr>
<td>rfic_digital_loopback </td><td>Digital data loopback inside the RFIC. </td><td>N310 </td><td>rfic_digital_loopback=1 </td></tr>
</table>
<h2><a class="anchor" id="n3xx_usage_init"></a>
Device Initialization</h2>
<p>To maximally speed up UHD, an initialization sequence is run when the device (or more accurately, the MPM service) starts. This means even on the first run of UHD, the device will already be initialized into a usable state. Note that it will always come up in a default state, which can be changed by modifying the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>), such as this:</p>
<div class="fragment"><div class="line">; Note: To boot into a fully initialized state, a clock reference must be</div><div class="line">; connected before turning the device on if it set to external here:</div><div class="line">[n3xx]</div><div class="line">clock_source=external</div></div><!-- fragment --><p>If you prefer not to have the device initialize on boot, but rather have a fast boot time, add the line <code>skip_boot_init=1</code> to your <code>/etc/uhd/mpm.conf</code> file.</p>
<p>For more details on the initialization sequence, see the corresponding section for the specific N3XX device:</p><ul>
<li><a class="el" href="page_usrp_n3xx.html#n3xx_mg_initialization">Device Initialization (Fast and Slow)</a></li>
</ul>
<h2><a class="anchor" id="n3xx_usage_subdevspec"></a>
Subdev Specifications</h2>
<p>The RF ports on the front panel of the N300/N310 correspond to the following subdev specifications:</p>
<table class="doxtable">
<tr>
<th>Label </th><th>Subdev Spec  </th></tr>
<tr>
<td>RF0 </td><td>A:0 </td></tr>
<tr>
<td>RF1 </td><td>A:1 </td></tr>
<tr>
<td>RF2 </td><td>B:0 (N310 only) </td></tr>
<tr>
<td>RF3 </td><td>B:1 (N310 only) </td></tr>
</table>
<p>The RF ports on the front panel of the N320/N321 correspond to the following subdev specifications:</p>
<table class="doxtable">
<tr>
<th>Label </th><th>Subdev Spec  </th></tr>
<tr>
<td>RF0 </td><td>A:0 </td></tr>
<tr>
<td>RF1 </td><td>B:0 </td></tr>
</table>
<p>Note: Before UHD 3.12.0.0, the subdev spec options were different (A:0, B:0, etc.). Make sure to update your application if you migrated from an earlier UHD version.</p>
<p>The following example will map RF0 onto channel 0 of a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a> object, and RF3 onto channel 1:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>(<span class="stringliteral">&quot;type=n3xx&quot;</span>);</div><div class="line">usrp-&gt;set_rx_subdev_spec(<span class="stringliteral">&quot;A:0 B:1&quot;</span>);</div><div class="line"><span class="comment">// This line will now set the gain for RF3 to 20.0:</span></div><div class="line">usrp-&gt;set_rx_gain(20.0, 1);</div><div class="line"><span class="comment">// And this will affect RF0:</span></div><div class="line">usrp-&gt;set_rx_gain(20.0, 0);</div></div><!-- fragment --><p>See also <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>.</p>
<h2><a class="anchor" id="n3xx_usage_sensors"></a>
The sensor API</h2>
<p>Like other USRPs, the N3x0 series have daughterboard and motherboard sensors. When using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>, the following API calls are relevant to interact with the sensor API:</p>
<ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">uhd::usrp::multi_usrp::get_mboard_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">uhd::usrp::multi_usrp::get_mboard_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">uhd::usrp::multi_usrp::get_tx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">uhd::usrp::multi_usrp::get_rx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">uhd::usrp::multi_usrp::get_tx_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">uhd::usrp::multi_usrp::get_rx_sensor()</a></li>
</ul>
<p>The following motherboard sensors are always available:</p>
<ul>
<li><code>ref_locked</code>: This will check that all the daughterboards have locked to the external reference.</li>
<li><code>temperature</code>: The temperature of the die itself</li>
<li><code>gps_lock</code>: GPS lock</li>
<li><code>gps_time</code>: GPS time in seconds sin ce the epch</li>
<li><code>gps_tpv</code>: A TPV report from GPSd serialized as JSON</li>
<li><code>gps_sky</code>: A SKY report from GPSd serialized as JSON</li>
</ul>
<h1><a class="anchor" id="n3xx_rasm"></a>
Remote Management</h1>
<h2><a class="anchor" id="n3xx_rasm_mender"></a>
Mender: Remote update capability</h2>
<p>Mender is a third-party software that enables remote updating of the root file system without physically accessing the device (see also the <a href="https://mender.io">Mender website</a>). Mender can be executed locally on the device, or a Mender server can be set up which can be used to remotely update an arbitrary number of USRP devices. Mender servers can be self-hosted, or hosted by Mender (see <a href="https://mender.io">mender.io</a> for pricing and availability).</p>
<p>When updating the file system using Mender, the tool will overwrite the root file system partition that is not currently mounted (note: every SD card comes with two separate root file system partitions, only one is ever used at a single time). Any data stored on that partition will be permanently lost. After updating that partition, it will reboot into the newly updated partition. Only if the update is confirmed by the user, the update will be made permanent. This means that if an update fails, the device will be always able to reboot into the partition from which the update was originally launched (which presumably is in a working state). Another update can be launched now to correct the previous, failed update, until it works. See also Section <a class="el" href="page_usrp_n3xx.html#n3xx_sdcard">The SD card</a>.</p>
<p>To initiate an update from the device itself, download a Mender artifact containing the update itself. These are files with a <code>.mender</code> suffix.</p>
<p>Then run mender on the command line: </p><pre class="fragment">$ mender -rootfs /path/to/latest.mender
</pre><p>The artifact can also be stored on a remote server: </p><pre class="fragment">$ mender -rootfs http://server.name/path/to/latest.mender
</pre><p>This procedure will take a while. After mender has logged a successful update, reboot the device: </p><pre class="fragment">$ reboot
</pre><p>If the reboot worked, and the device seems functional, commit the changes so the boot loader knows to permanently boot into this partition: </p><pre class="fragment">$ mender -commit
</pre><p>To identify the currently installed Mender artifact from the command line, the following file can be queried: </p><pre class="fragment">$ cat /etc/mender/artifact_info
</pre><p>If you are running a hosted server, the updates can be initiated from a web dashboard. From there, you can start the updates without having to log into the device, and can update groups of USRPs with a few clicks in a web GUI. The dashboard can also be used to inspect the state of USRPs. This is simple way to update groups of rack-mounted USRPs with custom file systems.</p>
<h2><a class="anchor" id="n3xx_rasm_salt"></a>
Salt: Remote configuration management and execution</h2>
<p>Salt (also known as SaltStack, see <a href="https://saltstack.com">Salt Website</a>) is a Python-based tool for maintaining fleets of remote devices. It can be used to manage USRP N3XX series remotely for all types of settings that are not controlled by UHD. For example, if an operator would like to reset the root password on multiple devices, or install custom software, this tool might be a suitable choice.</p>
<p>Salt is a third-party project with its <a href="https://docs.saltstack.com/en/latest/">own documentation</a>, which should be consulted for configuring it. However, the Salt minion is installed by default on every N3XX device. To start it, simply log on to the device and run: </p><pre class="fragment">$ systemctl start salt-minion
</pre><p>To permanently enable it at every boot, run (this won't by itself launch the salt-minion): </p><pre class="fragment">$ systemctl enable salt-minion
</pre><p>To make use of Salt, both the device needs to be configured (the "minion") and, typically, a server to act as the Salt master. Refer to the Salt documentation on how to configure the minion and the master. A typical sequence to get started will look like this:</p>
<ol type="1">
<li>Install the salt-master package on the server (e.g. by running <code>apt install salt-master</code> if the server is an Ubuntu system), and make sure the Salt master is running.</li>
<li>Add the network address / hostname of that server to the <code>/etc/salt/minion</code> file on the device by editing the <code>master:</code> line.</li>
<li>Launch the Salt minion on the USRP by running the command <code>systemctl start salt-minion</code>.</li>
<li>The minion will try to connect to the master. You need to authorize the minion by running <code>salt-key -a $hostname</code> where <code>$hostname</code> is the name of the minion.</li>
<li>Once the device is authorized, you can try various commands to see if the communication was established:</li>
</ol>
<pre class="fragment">$ [sudo] salt '*' test.ping
ni-n3xx-311FE00:
    True
$ [sudo] salt '*' network.interfaces
ni-n3xx-311FE00:
    ----------
    eth0:
        ----------
        hwaddr:
            02:00:03:11:fe:00
        inet:
            |_
              ----------
              address:
                  10.16.32.113
              broadcast:
                  10.16.33.255
              label:
                  eth0
              netmask:
                  255.255.254.0
        up:
            True
$ [...]
</pre><h1><a class="anchor" id="n3xx_synchronization"></a>
Clock/Time Synchronization</h1>
<h2><a class="anchor" id="n3xx_synchronization_internal"></a>
Internal references</h2>
<p>The N3xx series has an onboard GPSDO as well as a 25 MHz reference oscillator, which can both be used as time- and clock references. The GPSDO will function as a reference even when there is no GPS reception. It can be powered off to reduce power usage and interference by supplying the <code>enable_gps=0</code> option in the configuration file (in this case, <code>gpsdo</code> cannot be used as a time or clock reference).</p>
<p>Note that this does not enable the synchronization of multiple devices. Using an internal reference is the default.</p>
<h2><a class="anchor" id="n3xx_synchronization_external"></a>
External references</h2>
<p>In order to synchronize multiple USRPs, an external reference, such as the CDA-2990 (OctoClock), is required. If only a clock reference is available, it is possible to derive an internal PPS signal from the reference (which will allow devices to share a frequency, but not a time reference). If both an external clock and time source are provided, devices will be synchronized in frequency and time.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(</div><div class="line">    <span class="stringliteral">&quot;type=n3xx,clock_source=external,time_source=external&quot;</span>);</div></div><!-- fragment --><p> To reduce phase noise, it may be necessary to power down the GPSDO when using an external reference. To do this, just add <code>enable_gps=False</code> to the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>).</p>
<p>Note: When disabling the GPS with <code>enable_gps=0</code> in the configuration file, or when manually launching MPM, the <code>gpsdo</code> reference source is not available.</p>
<h2><a class="anchor" id="n3xx_synchronization_whiterabbit"></a>
White Rabbit</h2>
<p>White Rabbit is an Ethernet-based synchronization procedure; it is an extension of the IEEE 1588 Precision Time Protocol (PTP). The N3xx device can be configured as a White Rabbit slave.</p>
<p>To use White Rabbit, it is necessary to provide an appropriate reference via Ethernet. This reference must be connected to SFP0. Finally, a White Rabbit-compatible FPGA must be loaded. SFP0 will <em>not be available for data transport</em> in this mode.</p>
<p>The White Rabbit image is provided as a default image. To obtain the default images, simply run: </p><pre class="fragment">$ uhd_images_downloader -t n3xx -t fpga
</pre><p>Then, you can install the WX (or WA) image using <code>uhd_image_loader</code>: </p><pre class="fragment">$ uhd_image_loader \
    --args type=n3xx,addr=ni-n3xx-&lt;DEVICE_SERIAL&gt;,WX
</pre><p>Once the image is loaded, select <code>internal</code> as the clock source and <code>sfp0</code> as the time source (note: this will fail if the WX or WA image is not currently loaded):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(</div><div class="line">    <span class="stringliteral">&quot;type=n3xx,clock_source=internal,time_source=sfp0&quot;</span>);</div><div class="line"><span class="comment">// Or if you want to change it to White Rabbit after initialization:</span></div><div class="line">usrp-&gt;set_sync_source(device_addr_t(<span class="stringliteral">&quot;clock_source=internal,time_source=sfp0&quot;</span>));</div><div class="line"><span class="comment">// Using the older time/clock source APIs is also possible:</span></div><div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;sfp0&quot;</span>);</div><div class="line">usrp-&gt;set_clock_source(<span class="stringliteral">&quot;internal&quot;</span>);</div><div class="line"><span class="comment">// The 2nd call can technically be skipped because the device implementations</span></div><div class="line"><span class="comment">// will coerce, but for consistency with other code and for being explicit this</span></div><div class="line"><span class="comment">// is the preferred way. The 2nd call will immediately return in this case.</span></div></div><!-- fragment --><p>For more information, refer to the <a href="https://www.ohwr.org/projects/white-rabbit">White Rabbit Homepage</a>, or the <a href="https://kb.ettus.com/Using_Ethernet-Based_Synchronization_on_the_USRP%E2%84%A2_N3xx_Devices">Ettus Research Knowledge Base</a>.</p>
<h1><a class="anchor" id="n3xx_troubleshooting"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="n3xx_troubleshooting_seqerrs"></a>
Errors while streaming</h2>
<p>If you are getting sequence or other errors while streaming, make sure the MTU settings of the network devices match up. UHD will try and do an automatic MTU discovery, but there are cases when the automatic MTU discovery will yield incorrect values. Often, the host computer MTU is set smaller than the device MTU, but the MTU discovery will detect a larger MTU than the host computer MTU in this error case.</p>
<p>The default MTU for the N3x0 series is 8000. The simplest solution is often to set the host computer MTU to 8000 as well: </p><pre class="fragment">$ [sudo] ifconfig eth0 mtu 8000 # Replace eth0 with the device you're using
</pre><p>Of course, you can also reduce the MTU on the device to match your host computer, see Section <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_connectivity">Network Connectivity</a>.</p>
<h2><a class="anchor" id="n3xx_troubleshooting_bist"></a>
Built-in Self-Test (BiST)</h2>
<p>The N3x0 series devices have a built-in self-test that can be used to verify the hardware. It is not automatically run, but it can be invoked anytime by running the <code>n3xx_bist</code> executable. Calling </p><pre class="fragment">n3xx_bist -h
</pre><p>will list the available options. Tests can be run by specifying their name, e.g. </p><pre class="fragment">n3xx_bist gpsdo
</pre><p>will test the functionality of the GPSDO. Calling <code>n3xx_bist standard</code> will run a standard set of tests, verifying some base peripherals such as the RTC, the fan and temperature sensors, etc.</p>
<p>Some tests require special hardware connected. For example, there are multiple tests to verify the SFP+ adapters. There are two types of test for those: For the <code>sfp0_loopback</code> and <code>sfp1_loopback</code> tests, a loopback module must be plugged into the SFP+. For the <code>sfp_loopback</code> test, the two ports need to be connected together.</p>
<p>Tests may also load different FPGA images, if required. The aforementioned SFP tests will load the AA FPGA image and use Aurora to run the BER tests on the SFP ports. This is particularly relevant if either a custom image was loaded, or if there is an active SSH or other connection coming in via the SFP+ ports.</p>
<h1><a class="anchor" id="n3xx_theory_of_ops"></a>
Theory of Operation</h1>
<p>The N3xx-series are devices based on the MPM architecture (see also: <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>). Inside the Linux operating system running on the ARM cores, there is hardware daemon which needs to be active in order for the device to function as a USRP (it is enabled to run by default).</p>
<p>A large portion of hardware-specific setup is handled by the daemon.</p>
<h1><a class="anchor" id="n3xx_fsbuild"></a>
Building custom filesystems and SD card images</h1>
<p>Ettus Research provides SD card images at regular intervals, but there can be good reasons to build custom SD cards, e.g., to test the very latest UHD or MPM for which there has not been an SD card release, to add own applications to the SD card, or to run a modified version of UHD.</p>
<p>Note that building SD cards is very disk space and RAM intensive.</p>
<h2><a class="anchor" id="n3xx_fsbuild_docker"></a>
Using Docker to build filesystems</h2>
<p>Ettus Research provides a Docker containers to facilitate building filesystems. Refer to the <a href="https://github.com/EttusResearch/ettus-docker/blob/master/oe-build/README.md">README </a> for more details.</p>
<h1><a class="anchor" id="n3xx_software_dev"></a>
Modifying and compiling UHD and MPM for the N3XX</h1>
<p>N3xx devices ship with all relevant software installed on the SD card. Updating UHD and/or MPM on the SD card is typically easiest done by updating the filesystem image (see Section <a class="el" href="page_usrp_n3xx.html#n3xx_rasm_mender">Mender: Remote update capability</a>). However, it is certainly possible to compile UHD and MPM by hand, e.g., in order to modify and try out changes without having to build entire filesystems in between. At Ettus R&amp;D, this mode of operation is often used for rapid iteration cycles.</p>
<h2><a class="anchor" id="n3xx_software_dev_mpm_native"></a>
Compiling MPM natively</h2>
<p>In general, compiling natively is not a recommended way of compiling code for the ARM processors. However, in the case of MPM, the amount of C++ code that needs to be compiled is very little, and a full compile of MPM will take a few minutes even on the N3xx. First, you need to get a copy of the MPM source code onto your device. If you have an internet connection, you can use git to pull it directly from the Ettus repository (all commands are run on the device itself, inside the home directory): </p><pre class="fragment">$ git clone https://github.com/EttusResearch/uhd.git
</pre><p>You can also SSHFS it from another computer: </p><pre class="fragment">$ mkdir uhd # Create a new, empty directory called uhd
$ sshfs user@yourcomputer:src/uhd uhd # This will mount ~/src/uhd from the remote machine to ~/uhd on the N3xx
</pre><p>Now, create a build directory and use the regular cmake/make procedure to kick off a build. It can be advantageous (especially for slow network connections) to create the build directory outside of the repository directory: </p><pre class="fragment">$ mkdir build_mpm
$ cd build_mpm # You are now in /home/root/build_mpm
$ cmake ../uhd/mpm
$ make -j2 install # This will take several minutes
</pre><p>Note that this overwrites your system MPM. You can install MPM to another location by specifying <code>-DCMAKE_INSTALL_PREFIX</code>, but make sure to update all of your paths appropriately.</p>
<p>If you prefer cross-compiling MPM the same way as UHD, refer to the following sections and adapt the instructions for UHD appropriately.</p>
<h2><a class="anchor" id="n3xx_software_dev_sdk"></a>
Obtaining an SDK</h2>
<p>The recommended way to develop software for the N3xx is to cross-compile. By running the compiles on a desktop or laptop computer, you will be able to speed up compile times considerably (compiling UHD natively for the N3xx would take many hours).</p>
<p>SDKs are distributed along with other binaries. They contain a cross-compiler, a cross-linker, a cross-debugger, and all the libraries available on the device to mirror its environment.</p>
<p>The SDK is shipped in the same way as the other binaries, and you can download the correct version using <code>uhd_images_downloader</code> </p><pre class="fragment">$ uhd_images_downloader -t sdk -t n3xx
</pre><p>To unpack and install the SDK, simply execute it after downloading it: </p><pre class="fragment">$ cd /usr/local/share/uhd/images # Change this to where your images are stored
$ ./oecore-x86_64-cortexa9hf-neon-toolchain-nodistro.0.sh
</pre><p>If this doesn't work, the executable permissions of the file might have been lost (this can occur with some versions of Python). In that case, add those permissions back before executing the <code>.sh</code> file: </p><pre class="fragment">$ chmod +x oecore-x86_64-cortexa9hf-neon-toolchain-nodistro.0.sh
</pre><p>Executing the <code>.sh</code> file will prompt you for an installation path. Please ensure you have sufficient disk space, as each of the SDKs may require several gigabytes of disk space (depending on the image flavor selected).</p>
<p>This will allow you to compile UHD as well as (depending on the image flavor) other software, such as GNU Radio.</p>
<p>Please note, that while several toolchains can be installed in parallel, they have to be installed to different directories.</p>
<h2><a class="anchor" id="n3xx_software_dev_sdkusage"></a>
SDK Usage</h2>
<p>Having installed the toolchain in the last step, in order to build software for your device open a new shell and type: </p><pre class="fragment">$ . $SDKPATH/environment-setup-armv7ahf-vfp-neon-oe-linux-gnueabi
</pre><p>This will modify the PATH, CC, CXX etc, environment variables and allow you to compile software for your USRP N3xx device. To verify all went well you can try: </p><pre class="fragment">$ $CC -dumpmachine
</pre><p>which should return 'arm-oe-linux-gnueabi'.</p>
<h3><a class="anchor" id="n3xx_software_dev_uhd"></a>
Building UHD</h3>
<ol type="1">
<li>Obtain the UHD source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_n3xx.html#n3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Type the following in the build directory (assuming a build in host/build): <pre class="fragment"> $ cmake -DCMAKE_TOOLCHAIN_FILE=../host/cmake/Toolchains/oe-sdk_cross.cmake -DCMAKE_INSTALL_PREFIX=/usr .. # Add any CMake options you desire
 $ make # You can run make -j12 to compile on 12 processes at once
</pre></li>
</ol>
<p>Note: The UHD you are cross-compiling will not run on your host computer (the one where you're doing the development). Compiling UHD regularly on your host computer (with MPMD enabled) will allow you to talk to your N3xx.</p>
<h3><a class="anchor" id="n3xx_software_dev_gr"></a>
Building GNU Radio</h3>
<ol type="1">
<li>Obtain the GNU Radio source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_n3xx.html#n3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Use the following commands to create a build directory, configure and compile gnuradio. You only need create the build directory once.</li>
</ol>
<div class="fragment"><div class="line">$ mkdir build-arm</div><div class="line">$ cd build-arm</div><div class="line">$ cmake -Wno-dev -DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchains/oe-sdk_cross.cmake \-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_GR_VOCODER=OFF -DENABLE_GR_ATSC=OFF \</div><div class="line">-DENABLE_GR_DTV=OFF -DENABLE_DOXYGEN=OFF ../ # Append any CMake options you desire</div></div><!-- fragment --><p>Several GNU Radio components depend on running binaries built for the build machine during compile. These binaries can be built and used for cross compiling, but this is an advanced topic.</p>
<h1><a class="anchor" id="n3xx_mg"></a>
N310-specific Features</h1>
<h2><a class="anchor" id="n3xx_mg_panels"></a>
Front and Rear Panel</h2>
<p>Like the USRP X300 series, the N310 has connectors on both the front and back panel. The back panel holds the power connector, all network connections, USB connections for serial console (see <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>), JTAG, peripherals, SMA connectors for GPS antenna input, 10 MHz clock reference, PPS time reference input and output (TRIG in/out), the slot for the SD card (see also <a class="el" href="page_usrp_n3xx.html#n3xx_sdcard">The SD card</a>), and indicator LEDs.</p>
<p>The following indicator LEDs are used:</p>
<ul>
<li>LINK: This LED will be lit when this USRP has been claimed by a UHD session.</li>
<li>REF: Indicates a lock to the reference clock. In particular, when using an external reference clock, this LED is useful to see if the LMK04828 PLLs are locking to this reference clock. Note that some software interaction is necessary to enable the LMK04828, and thus this LED may be off even if a valid reference clock signal is connected.</li>
<li>GPS: Indicates a GPS lock (i.e., GPS satellites are in view of the GPS antenna and signal levels are sufficient)</li>
<li>PPS: This LED will blink once every second to indicate a valid PPS signal.</li>
</ul>
<div class="image">
<img src="N310rp.png" alt="N310rp.png"/>
<div class="caption">
N310 Rear Panel</div></div>
<p>The front panel is used for all RF connections (including the external LO inputs, see <a class="el" href="page_usrp_n3xx.html#n3xx_mg_external_lo">External LOs</a>) and all TX/RX connections, as well as the front-panel GPIO.</p>
<p>The connectors labeled RF0 and RF1 are also referred to as slot A, and the connectors labeled RF2 and RF3 are also referred as slot B (matching the internal connections to the daughterboard. Every slot is powered by a single AD9371 RFIC).</p>
<div class="image">
<img src="N310fp.png" alt="N310fp.png"/>
<div class="caption">
N310 Front Panel</div></div>
<h2><a class="anchor" id="n3xx_mg_initialization"></a>
Device Initialization (Fast and Slow)</h2>
<p>When a UHD session is created, an initialization sequence is started. As part of the initialization sequence, the following steps are performed:</p>
<ul>
<li>All clocking is initialized</li>
<li>The JESD links are trained and brought up (between the FPGA and the AD9371)</li>
<li>The AD9371 is reset, its firmware is uploaded, and calibrations are initialized (See also <a class="el" href="page_usrp_n3xx.html#n3xx_mg_calibrations">RF Calibrations</a>)</li>
<li>N310 only: The multi-chip synchronization is performed to align all the RFICs to the common time and clock reference</li>
</ul>
<p>This sequence can take a while, depending on the master clock rate and the calibration sequence. To speed things up, the device will retain a state between sessions, but only if no relevant settings were touched. In particular, changing the master clock rate, the clock source, or the calibration masks will force a full re-initialization which is very slow compared to the fast re-initialization. By setting the log level to DEBUG you will be able to observe the exact settings that cause fast vs. slow re-initialization. If you require a full re-initialization every time a UHD session is spawned, specify the <code>force_reinit</code> flag as a device arg. Specifying it will always do the full, slow initialization, but will guarantee a full reset of the RFIC.</p>
<p>To maximally speed up UHD, an initialization sequence is run when the device (or more accurately, the MPM service) starts. This means even on the first run of UHD, the device will already be initialized into a usable state. Note that it will always come up in a default state, which can be changed by modifying the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>), such as this:</p>
<div class="fragment"><div class="line">; Note: To boot into a fully initialized state, a clock reference must be</div><div class="line">; connected before turning the device on if it set to external here:</div><div class="line">[n3xx]</div><div class="line">master_clock_rate=122.88e6</div><div class="line">clock_source=external</div></div><!-- fragment --><p>If you prefer not to have the device initialize on boot, but rather have a fast boot time, add the line <code>skip_boot_init=1</code> to your <code>/etc/uhd/mpm.conf</code> file.</p>
<h2><a class="anchor" id="n3xx_mg_calibrations"></a>
RF Calibrations</h2>
<p>The onboard RFIC (AD9371) has built-in calibrations which can be enabled from UHD. A more detailed description of the calibrations can be found in the AD9371 user guide, see chapter "Quadrature Error Correction, Calibration, and ARM
configuration".</p>
<p>Not all calibrations available on the AD9371 are applicable to the USRP N310. However, those calibrations that are applicable can be enabled/disabled at initialization time using the <code>tracking_cals</code> and <code>init_cals</code> device args (see also <a class="el" href="page_usrp_n3xx.html#n3xx_usage_device_args">Device arguments</a>). These device can be set to the precise bit mask the chip uses to set those calibrations (e.g., <code>init_cals=0x4DFF,tracking_cals=0xC3</code>) or they can use the following descriptive keys provided by UHD (e.g.<code>init_cals=DEFAULT,tracking_cals=TX_QEC|RX_QEC</code>). The <code>|</code> symbol can be used to combine keys (equivalent to a bitwise OR).</p>
<p>Calibrations can significantly delay the initialization of a session. By only picking relevant calibrations, sessions can be initialized faster.</p>
<table class="doxtable">
<tr>
<th>Key (<code>init_cal</code>) </th><th>Function  </th></tr>
<tr>
<td>TX_BB_FILTER </td><td>Tx baseband filter calibration </td></tr>
<tr>
<td>ADC_TUNER </td><td>ADC tuner calibration </td></tr>
<tr>
<td>TIA_3DB_CORNER </td><td>Rx TIA filter calibration </td></tr>
<tr>
<td>DC_OFFSET </td><td>Rx DC offset calibration </td></tr>
<tr>
<td>TX_ATTENUATION_DELAY </td><td>Tx attenuation delay </td></tr>
<tr>
<td>RX_GAIN_DELAY </td><td>Rx gain delay calibration </td></tr>
<tr>
<td>FLASH_CAL </td><td>ADC flash calibration </td></tr>
<tr>
<td>PATH_DELAY </td><td>Path delay calibration </td></tr>
<tr>
<td>TX_LO_LEAKAGE_INTERNAL </td><td>Tx LO leakage internal initial calibration </td></tr>
<tr>
<td>TX_LO_LEAKAGE_EXTERNAL </td><td>Tx LO leakage external initial calibration (requires external LO) </td></tr>
<tr>
<td>TX_QEC_INIT </td><td>Tx QEC initial </td></tr>
<tr>
<td>LOOPBACK_RX_LO_DELAY </td><td>Loopback ORx LO delay (ORx not connected by default!) </td></tr>
<tr>
<td>LOOPBACK_RX_RX_QEC_INIT </td><td>Loopback Rx QEC initial calibration </td></tr>
<tr>
<td>RX_LO_DELAY </td><td>Rx LO delay </td></tr>
<tr>
<td>RX_QEC_INIT </td><td>Rx QEC initial calibration </td></tr>
<tr>
<td>BASIC </td><td>Preset for minimal calibrations (TX_BB_FILTER, ADC_TUNER, TIA_3DB_CORNER, DC_OFFSET and FLASH_CAL) </td></tr>
<tr>
<td>OFF </td><td>Preset for disabling all initial calibrations </td></tr>
<tr>
<td>DEFAULT </td><td>Preset for enabling most calibrations (BASIC plus TX_ATTENUATION_DELAY, RX_GAIN_DELAY, PATH_DELAY, RX_QEC_INIT, TX_LO_LEAKAGE_INTERNAL, TX_QEC_INIT, LOOPBACK_RX_LO_DELAY) </td></tr>
<tr>
<td>ALL </td><td>Enable all applicable calibrations </td></tr>
</table>
<table class="doxtable">
<tr>
<th>Key (<code>tracking_cal</code>) </th><th>Function  </th></tr>
<tr>
<td>TRACK_RX1_QEC </td><td>Rx1 QEC tracking </td></tr>
<tr>
<td>TRACK_RX2_QEC </td><td>Rx2 QEC tracking </td></tr>
<tr>
<td>TRACK_ORX1_QEC </td><td>ORx1 QEC tracking </td></tr>
<tr>
<td>TRACK_ORX2_QEC </td><td>ORx1 QEC tracking </td></tr>
<tr>
<td>TRACK_TX1_LOL </td><td>Tx1 LO leakage tracking </td></tr>
<tr>
<td>TRACK_TX2_LOL </td><td>Tx2 LO leakage tracking </td></tr>
<tr>
<td>TRACK_TX1_QEC </td><td>Tx1 QEC tracking </td></tr>
<tr>
<td>TRACK_TX2_QEC </td><td>Tx2 QEC tracking </td></tr>
<tr>
<td>OFF </td><td>Disable all tracking </td></tr>
<tr>
<td>RX_QEC </td><td>Enable all RX QEC tracking </td></tr>
<tr>
<td>TX_QEC </td><td>Enable all TX QEC tracking </td></tr>
<tr>
<td>TX_LOL </td><td>Enable all TX LO leakage tracking </td></tr>
<tr>
<td>DEFAULT </td><td>Enable all QEC tracking </td></tr>
<tr>
<td>ALL </td><td>Enable all tracking (except ORx) </td></tr>
</table>
<h2><a class="anchor" id="n3xx_mg_external_lo"></a>
External LOs</h2>
<p>The N310 has inputs for external local oscillators. For every daughterboard, there is one input for TX and RX, respectively, resulting in 4 LO inputs total per N310.</p>
<p>Reasons to use an external LO include:</p>
<ul>
<li>Improving phase alignment: The N310 itself has no way of aligning phase between channels, and phase will be random between runs. By applying an external LO, the phase ambiguity is reduced to 180 degrees, produced by a by-2 divider in the AD9371 transceiver IC.</li>
<li>Improving phase noise: The quality of the onboard LO depends on the external reference clock, among other things. By providing a custom LO signal, it is possible to more accurately tune, assuming the externally generated LO signal is coming from a high-quality oscillator.</li>
</ul>
<h2><a class="anchor" id="n3xx_mg_eeprom"></a>
Storing user data in the EEPROM</h2>
<p>The N310 daughterboard has an EEPROM which is primarily used for storing the serial number, product ID, and other product-specific information. However, it can also be used to store user data, such as calibration information.</p>
<p>Note that EEPROMs have a limited number of write cycles, and storing user data should happen only when necessary. Writes should be kept at a minimum.</p>
<p>Storing data on the EEPROM is done by loading a <a class="el" href="namespaceuhd.html#a3dfa664f90d28b4e602a6d780ce0edd0">uhd::eeprom_map_t</a> object into the property tree. On writing this property, the driver code will serialize the map into a binary representation that can be stored on the EEPROM.</p>
<h2><a class="anchor" id="n3xx_mg_revs"></a>
Module and Motherboard/Daughterboard Revisions</h2>
<p>The N310 module consists of three PCBs: The motherboard and two daughterboards. Every PCB has a hardware revision number. Modules are always assembled such that the daughterboards have the same revision number. The module revision number is derived from the combination of daughterboard and motherboard hardware revisions. The following table explains which module revision contains which PCB revisions:</p>
<table class="doxtable">
<tr>
<th>Module Revision </th><th>Motherboard Revision </th><th>Daughterboard Revision </th><th>Minimum UHD Version  </th></tr>
<tr>
<td>A </td><td>D </td><td>D </td><td>3.11.0.0 </td></tr>
<tr>
<td>B </td><td>F </td><td>E </td><td>3.12.0.0 </td></tr>
<tr>
<td>C </td><td>G </td><td>E </td><td>3.13.0.2 </td></tr>
<tr>
<td>D </td><td>H </td><td>E </td><td>3.14.0.0 </td></tr>
</table>
<p>The module revision is printed on the sticker on the underside of an N310 module chassis, it is contained within the part number. For example, if the sticker says "P/N: 141064A-01L", it is a revision A module.</p>
<h2><a class="anchor" id="n3xx_mg_regmap"></a>
FPGA Register Map</h2>
<p>The following tables describe how FPGA registers are mapped into the PS. This is for reference only, most users will not even have to know about this table.</p>
<table class="doxtable">
<tr>
<th>AXI Slave </th><th>Address Range </th><th>UIO Label </th><th>Description  </th></tr>
<tr>
<td>Slave 0 </td><td>4000_0000 - 4000_3fff </td><td>- </td><td>Ethernet DMA SFP0 </td></tr>
<tr>
<td>Slave 1 </td><td>4000_4000 - 4000_4fff </td><td>misc-enet-regs0 </td><td>Ethernet registers SFP0 </td></tr>
<tr>
<td>Slave 2 </td><td>4000_8000 - 4000_bfff </td><td>- </td><td>Ethernet DMA SFP1 </td></tr>
<tr>
<td>Slave 3 </td><td>4000_c000 - 4000_cfff </td><td>misc-enet-regs1 </td><td>Ethernet registers SFP1 </td></tr>
<tr>
<td>Slave 4 </td><td>4001_0000 - 4001_3fff </td><td>mboard-regs </td><td>Motherboard control </td></tr>
<tr>
<td>Slave 5 </td><td>4001_4000 - 4001_41ff </td><td>dboard-regs0 </td><td>Daughterboard control, slot A </td></tr>
<tr>
<td>Slave 6 </td><td>4001_8000 - 4001_bfff </td><td>dboard-regs1 </td><td>Daughterboard control, slot B </td></tr>
</table>
<a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>N310 Register Map</caption>
<tr>
<th>AXI Slave </th><th>Module </th><th>Address </th><th>Name </th><th>Read/Write </th><th>Description </th></tr>
<tr>
<td rowspan="1">Slave 0 </td><td rowspan="1">axi_eth_dma0 </td><td>4000_0000 - 4000_4fff </td><td>Ethernet DMA </td><td>RW </td><td>See Linux Driver </td></tr>
<tr>
<td rowspan="44">Slave 1 </td><td rowspan="7">n3xx_mgt_io_core </td><td>4000_4000 </td><td>PORT_INFO </td><td>RO </td><td>SFP port information </td></tr>
<tr>
<td>[31:24] </td><td>COMPAT_NUM </td><td>RO </td><td>- </td></tr>
<tr>
<td>[23:18] </td><td>6'h0 </td><td>RO </td><td>- </td></tr>
<tr>
<td>[17] </td><td>activity </td><td>RO </td><td>- </td></tr>
<tr>
<td>[16] </td><td>link_up </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:8] </td><td>mgt_protocol </td><td>RO </td><td>0 - None, 1 - 1G, 2 - XG, 3 - Aurora </td></tr>
<tr>
<td>[7:0] </td><td>PORTNUM </td><td>RO </td><td>- </td></tr>
<tr>
<td rowspan="8">n3xx_mgt_io_core </td><td>4000_4004 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td>Control 10gE and Aurora mac </td></tr>
<tr>
<td>[0] </td><td>ctrl_tx_enable (PROTOCOL = "10GbE")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[0] </td><td>bist_checker_en (PROTOCOL = "Aurora")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[1] </td><td>bist_gen_en </td><td>RW </td><td>- </td></tr>
<tr>
<td>[2] </td><td>bist_loopback_en</td><td>RW </td><td>- </td></tr>
<tr>
<td>[8:3] </td><td>bist_gen_rate </td><td>RW </td><td>- </td></tr>
<tr>
<td>[9] </td><td>phy_areset </td><td>RW </td><td>- </td></tr>
<tr>
<td>[10] </td><td>mac_clear </td><td>RW </td><td>- </td></tr>
<tr>
<td>n3xx_mgt_io_core </td><td>4000_4008 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td>Phy reset control </td></tr>
<tr>
<td rowspan="3">n3xx_mgt_io_core </td><td>4000_400C </td><td>MAC_LED_CTL </td><td>RW </td><td>Used by ethtool to indicate port </td></tr>
<tr>
<td>[1] </td><td>identify_enable </td><td>RW </td><td>- </td></tr>
<tr>
<td>[0] </td><td>identify_value </td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">mdio_master </td><td>4000_4010 </td><td>MDIO_DATA </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4014 </td><td>MDIO_ADDR </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4018 </td><td>MDIO_OP </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_401C </td><td>MDIO_CTRL_STATUS</td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">n3xx_mgt_io_core </td><td>4000_4020 </td><td>AURORA_OVERUNS </td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4024 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4028 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_402C </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td>- </td></tr>
<tr>
<td rowspan="4">eth_switch </td><td>4000_5000 </td><td>MAC_LSB </td><td>RW </td><td>Device MAC LSB </td></tr>
<tr>
<td>4000_5004 </td><td>MAC_MSB </td><td>RW </td><td>Device MAC MSB </td></tr>
<tr>
<td>4000_6000 </td><td>IP </td><td>RW </td><td>Device IP </td></tr>
<tr>
<td>4000_6004 </td><td>PORT1, PORT0 </td><td>RW </td><td>Device UDP port </td></tr>
<tr>
<td rowspan="2">eth_dispatch </td><td>4000_6008 </td><td>[1] ndest, [0] bcast</td><td>RW </td><td>Enable Crossover </td></tr>
<tr>
<td>4000_600c </td><td>[1] my_icmp_type, [0] my_icmp_code</td><td></td></tr>
<tr>
<td rowspan="5">eth_switch </td><td>4000_6010 </td><td>BRIDGE_MAC_LSB </td><td></td><td>Bridge SFP ports in ARM </td></tr>
<tr>
<td>4000_6014 </td><td>BRIDGE_MAC_MSB </td><td></td><td>- </td></tr>
<tr>
<td>4000_6018 </td><td>BRIDGE_IP </td><td></td><td>- </td></tr>
<tr>
<td>4000_601c </td><td>BRIDGE_PORT1, BRIDGE_PORT0</td><td></td><td>- </td></tr>
<tr>
<td>4000_6020 </td><td>BRIDGE_EN </td><td></td><td>- </td></tr>
<tr>
<td rowspan="6">chdr_eth_framer </td><td>4000_6108 onwards </td><td>LOCAL_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 256 SIDs </td></tr>
<tr>
<td>4000_6208 onwards </td><td>LOCAL_DST_UDP_MAC_MSB</td><td>W </td><td>Destination MAC for outgoing packets (MSB) </td></tr>
<tr>
<td>4000_6308 onwards </td><td>LOCAL_DST_MAC_LSB</td><td>W </td><td>Destination MAC for outgoing packets (LSB) </td></tr>
<tr>
<td>4000_7000 onwards </td><td>REMOTE_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 16 local addrs </td></tr>
<tr>
<td>4000_7400 onwards </td><td>REMOTE_DST_UDP_MAC_HI</td><td>W </td><td>Destination MAC (MSB) </td></tr>
<tr>
<td>4000_7800 onwards </td><td>REMOTE_DST_MAC_LO</td><td>W </td><td><p class="starttd">Destination MAC (LSB)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="1">Slave 2 </td><td>axi_eth_dma1 </td><td>4000_8000 </td><td>- </td><td></td><td><p class="starttd">Same as Slave 0, different base address</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="3">Slave 3 </td><td>n3xx_mgt_io_core </td><td>4000_c001 - 4000_cfff </td><td>- </td><td>- </td><td>Same as Slave 1, different base address </td></tr>
<tr>
<td>eth_dispatch </td><td>4000_d000 - 4000_dfff </td><td>- </td><td>- </td><td>Same as Slave 1, different base address </td></tr>
<tr>
<td>eth_switch </td><td>4000_e000 - 4000_efff </td><td>- </td><td>- </td><td><p class="starttd">Same as Slave 1, different base address</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="69">Slave 4 </td><td rowspan="22">n310_core </td><td>4001_0000 </td><td>COMPAT_NUM </td><td>R </td><td>FPGA Compat Number </td></tr>
<tr>
<td>[31:16] </td><td>Major </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:0] </td><td>Minor </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0004 </td><td>DATESTAMP </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0008 </td><td>GIT_HASH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_000C </td><td>SCRATCH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0010 </td><td>NUM_CE </td><td>RO </td><td>Number of Computation Engines (RFNoC Blocks) </td></tr>
<tr>
<td>4001_0014 </td><td>NUM_IO_CE </td><td>RO </td><td>Number of fixed IO CEs - Radios + DMA Fifo </td></tr>
<tr>
<td>4001_0018 </td><td>CLOCK_CTRL </td><td></td><td></td></tr>
<tr>
<td>[0] </td><td>pps select (internal 10 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the external PPS input. </td></tr>
<tr>
<td>[1] </td><td>pps select (internal 25 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the internally generated PPS with a 10 MHz ref_clk. </td></tr>
<tr>
<td>[2] </td><td>pps select (external)</td><td>RW </td><td>One-hot encoded pps_select to use the internally generated PPS with a 25 MHz ref_clk. </td></tr>
<tr>
<td>[3] </td><td>pps select (GPSDO)</td><td>RW </td><td>One-hot encoded pps_select to use the PPS from the GPSDO input to the FPGA. </td></tr>
<tr>
<td>[4] </td><td>pps output enable</td><td>RW </td><td></td></tr>
<tr>
<td>[8] </td><td>ref clk mmcm reset</td><td>WO </td><td>- </td></tr>
<tr>
<td>[9] </td><td>ref clk mmcm locked</td><td>RO </td><td>- </td></tr>
<tr>
<td>[12] </td><td>meas clk mmcm reset</td><td>WO </td><td>- </td></tr>
<tr>
<td>[13] </td><td>meas clk mmcm locked</td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_001C </td><td>XADC_READBACK </td><td>RO </td><td>- </td></tr>
<tr>
<td>[11:0] </td><td>FPGA temperature</td><td>RO </td></tr>
<tr>
<td>4001_0020 </td><td>BUS_CLK_RATE </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0024 </td><td>BUS_CLK_COUNT </td><td>RO </td><td>- </td></tr>
<tr>
<td rowspan="5">axi_crossbar </td><td>4001_1010 </td><td>XBAR_VERSION </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1014 </td><td>XBAR_NUM_PORTS </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1018 </td><td>LOCAL_ADDR </td><td>RW </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1020 </td><td>remote_offset </td><td>WO </td><td>XBAR settings reg </td></tr>
<tr>
<td>4001_1420 </td><td>local_offset </td><td>WO </td><td>XBAR settings reg </td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (NPIO0) </td><td>4001_0200 </td><td>PORT_INFO </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0204 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0208 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0220 </td><td>AURORA_OVERUNS </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0224 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO </td><td></td></tr>
<tr>
<td>4001_0228 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO </td><td></td></tr>
<tr>
<td>4001_022c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (NPIO1) </td><td>4001_0240 </td><td>PORT_INFO </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0244 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0248 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0260 </td><td>AURORA_OVERUNS </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0264 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0268 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_026c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP0) </td><td>4001_0280 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0284 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0288 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02a0 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02a4 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02a8 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02ac </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP1) </td><td>4001_02c0 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02c4 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02c8 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02e0 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02e4 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02e8 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02ec </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP2) </td><td>4001_0300 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0304 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0308 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0320 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0324 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0328 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_032c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP3) </td><td>4001_0340 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0344 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0348 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0360 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0364 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0368 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_036C </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="6">Slave 5 </td><td>4001_4000</td><td>4001_41FF</td><td>Clocking</td><td>see Clocking regmap</td><td></td></tr>
<tr>
<td>4001_4200</td><td>4001_43FF</td><td>Sync</td><td>see Sync regmap</td><td></td></tr>
<tr>
<td>4001_4400</td><td>4001_45FF</td><td>open</td><td>open</td><td>open</td><td></td></tr>
<tr>
<td>4001_4600</td><td>4001_47FF</td><td>Daughterboard </td><td>see Daughterboard regmap (EISCAT)</td><td></td></tr>
<tr>
<td>4001_6000</td><td>4001_6FFF</td><td>JESD Core 0</td><td>see JESD regmap (EISCAT)</td><td></td></tr>
<tr>
<td>4001_7000</td><td>4001_7FFF</td><td>JESD Core 1</td><td>see JESD regmap (EISCAT)</td><td></td></tr>
<tr>
<td rowspan="1">Slave 6 </td><td>4001_8000 - 4001_bfff </td><td>see above </td><td>-</td><td>same as Slave 5</td><td></td></tr>
</table>
<h1><a class="anchor" id="n3xx_rh"></a>
N32x-specific Features</h1>
<h2><a class="anchor" id="n3xx_rh_panels"></a>
Front and Rear Panel</h2>
<p>Like the USRP X300 series, the N320/N321 has connectors on both the front and back panel. The back panel holds the power connector, all network connections, USB connections for serial console (see <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>), JTAG, peripherals, SMA connectors for GPS antenna input, 10 MHz clock reference, PPS time reference input and output (TRIG in/out), the slot for the SD card (see also <a class="el" href="page_usrp_n3xx.html#n3xx_sdcard">The SD card</a>), and indicator LEDs.</p>
<p>The following indicator LEDs are used:</p>
<ul>
<li>LINK: This LED will be lit when this USRP has been claimed by a UHD session.</li>
<li>REF: Indicates a lock to the reference clock. In particular, when using an external reference clock, this LED is useful to see if the LMK04828 PLLs are locking to this reference clock. Note that some software interaction is necessary to enable the LMK04828, and thus this LED may be off even if a valid reference clock signal is connected.</li>
<li>GPS: Indicates a GPS lock (i.e., GPS satellites are in view of the GPS antenna and signal levels are sufficient)</li>
<li>PPS: This LED will blink once every second to indicate a valid PPS signal.</li>
</ul>
<p>The rear panel is identical between the N320 and the N321 with the exception of the product name above the SFP+ connectors.</p>
<div class="image">
<img src="N320_Rear.png" alt="N320_Rear.png"/>
<div class="caption">
N320 Rear Panel</div></div>
<div class="image">
<img src="N321_Rear.png" alt="N321_Rear.png"/>
<div class="caption">
N321 Rear Panel</div></div>
<p>The front panel is used for all RF connections (including the external LO inputs, see <a class="el" href="page_usrp_n3xx.html#n3xx_rh_external_lo">External LOs</a>) and all TX/RX connections, as well as the front-panel GPIO (N320 only!).</p>
<p>The connectors labeled RF0 are also referred to as slot A, and the connectors labeled RF1 are also referred as slot B (matching the internal connections to the daughterboard).</p>
<div class="image">
<img src="N320_Front.png" alt="N320_Front.png"/>
<div class="caption">
N320 Front Panel</div></div>
<div class="image">
<img src="N321_Front.png" alt="N321_Front.png"/>
<div class="caption">
N321 Front Panel</div></div>
<h2><a class="anchor" id="n3xx_rh_initialization"></a>
Device Initialization (Fast and Slow)</h2>
<p>When a UHD session is created, an initialization sequence is started. As part of the initialization sequence, the following steps are performed:</p>
<ul>
<li>All clocking is initialized</li>
<li>The JESD links are trained and brought up (between the FPGA and the ADC/DAC)</li>
</ul>
<p>This sequence can take a while, depending on the master clock rate and the calibration sequence. To speed things up, the device will retain a state between sessions, but only if no relevant settings were touched. In particular, changing the master clock rate or the clock source will force a full re-initialization which is slower compared to the fast re-initialization. By setting the log level to DEBUG you will be able to observe the exact settings that cause fast vs. slow re-initialization. If you require a full re-initialization every time a UHD session is spawned, specify the <code>force_reinit</code> flag as a device arg. Specifying it will always do the full, slow initialization, but will guarantee a full reset digital chains.</p>
<p>To maximally speed up UHD, an initialization sequence is run when the device (or more accurately, the MPM service) starts. This means even on the first run of UHD, the device will already be initialized into a usable state. Note that it will always come up in a default state, which can be changed by modifying the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>), such as this:</p>
<div class="fragment"><div class="line">; Note: To boot into a fully initialized state, a clock reference must be</div><div class="line">; connected before turning the device on if it set to external here:</div><div class="line">[n3xx]</div><div class="line">master_clock_rate=200e6</div><div class="line">clock_source=external</div></div><!-- fragment --><p>If you prefer not to have the device initialize on boot, but rather have a fast boot time, add the line <code>skip_boot_init=1</code> to your <code>/etc/uhd/mpm.conf</code> file.</p>
<h2><a class="anchor" id="n3xx_rh_calibrations"></a>
RF Calibrations</h2>
<p>The N320/N321 can perform some simple calibration for I/Q imbalance and DC offset, the same way as the X300 series. Refer to <a class="el" href="page_calibration.html">Device Calibration</a> for more details.</p>
<h2><a class="anchor" id="n3xx_rh_external_lo"></a>
External LOs</h2>
<p>The N320/N321 can utilize an external LO that is connected to the front panel connectors. For the N320, the LO IN TX and LO IN RX connectors are used. For the N321, the RX LO IN1 and TX LO IN1 connectors are used. One or both daughterboards may use this external LO signal by setting the channel's LO source to "external". When the source is set to "external", reading the LO frequency will return the ideal frequency for an external LO source.</p>
<p>The nominal LO input level is +5 dBm. Actual LO input levels should be within +/- 2 dB of that value (i.e., between +3 dBm and +7 dBm).</p>
<h2><a class="anchor" id="n3xx_rh_lo_sharing"></a>
N321 LO Distribution Board</h2>
<p>The N321 has an additional board to perform LO signal splitting and distribution. The 4 output ports, OUT0 through OUT3, are driven by a 1:4 splitter which can be sourced from the corresponding IN0 front panel port or the LO on the daughterboard in slot A. To use the IN0 front panel port, set LO export enabled to false. To use the LO located on the daughterboard in slot A, set LO export enabled to true.</p>
<p>Each of the 4 output ports, OUT0 through OUT3, have an internal terminator which must be disabled before use. These can be controlled through the RFNoC radio block's API, the property tree, or directly through commands in the MPM shell.</p>
<div class="image">
<img src="N321_LO_Distribution_Block_Diagram.png" alt="N321_LO_Distribution_Block_Diagram.png"/>
<div class="caption">
N321 LO Distribution Diagram</div></div>
 <h2><a class="anchor" id="n3xx_rh_lo_chaining"></a>
N320/N321 LO Sharing</h2>
<p>By using matched length cabling with N321s, up to 16 modules can use both of their RX and TX channels while sharing a single N321's LO signal, resulting in a 32 by 32 channel single shared LO configuration. This 32 by 32 channel configuration can also utilize an external LO signal, allowing an already split external LO signal to support larger configurations of 64 by 64 channels, 128 by 128 channels, and larger.</p>
<p>The following diagram shows the connections necessary to create a 16 by 16 channel configuration with a single shared LO source.</p>
<div class="image">
<img src="N321_16_Channel_Example.png" alt="N321_16_Channel_Example.png"/>
<div class="caption">
N321 16 Channel LO Sharing</div></div>
 <h2><a class="anchor" id="n3xx_rh_sfp_protocols"></a>
SFP+ and QSFP+ protocols</h2>
<p>The protocols supported on the SFP+ and QSFP+ ports depend on the FPGA image currently loaded.</p>
<table class="doxtable">
<tr>
<th>Interface </th><th>HG </th><th>XG </th><th>XQ </th><th>AQ  </th></tr>
<tr>
<td>SFP+ 0 </td><td>1 GbE </td><td>10 GbE </td><td>White Rabbit </td><td>10 GbE </td></tr>
<tr>
<td>SFP+ 1 </td><td>10 GbE </td><td>10 GbE </td><td>Unused </td><td>10 GbE </td></tr>
<tr>
<td>QSFP+ lane 0 </td><td>Unused </td><td>Unused </td><td>10 GbE </td><td>Aurora </td></tr>
<tr>
<td>QSFP+ lane 1 </td><td>Unused </td><td>Unused </td><td>10 GbE </td><td>Aurora </td></tr>
<tr>
<td>QSFP+ lane 2 </td><td>Unused </td><td>Unused </td><td>Unused </td><td>Aurora </td></tr>
<tr>
<td>QSFP+ lane 3 </td><td>Unused </td><td>Unused </td><td>Unused </td><td>Aurora </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
