<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: uhd::usrp::multi_usrp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.15.0.main-0-37b7dc22</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classuhd_1_1usrp_1_1multi__usrp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classuhd_1_1usrp_1_1multi__usrp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uhd::usrp::multi_usrp Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="multi__usrp_8hpp_source.html">uhd/usrp/multi_usrp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uhd::usrp::multi_usrp:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classuhd_1_1usrp_1_1multi__usrp.png" usemap="#uhd::usrp::multi_5Fusrp_map" alt=""/>
  <map id="uhd::usrp::multi_5Fusrp_map" name="uhd::usrp::multi_5Fusrp_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d9112f5eac0b53a721f2a6c97021fc1"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a></td></tr>
<tr class="separator:a9d9112f5eac0b53a721f2a6c97021fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c904057108e52d685b27496a11518db"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c904057108e52d685b27496a11518db">~multi_usrp</a> (void)=0</td></tr>
<tr class="separator:a6c904057108e52d685b27496a11518db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac425be38f8e2a3463de440e1f2ae1b6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac425be38f8e2a3463de440e1f2ae1b6d">get_device</a> (void)=0</td></tr>
<tr class="separator:ac425be38f8e2a3463de440e1f2ae1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292dcf0faa3d6b5c88cd46f1e589bbf6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a292dcf0faa3d6b5c88cd46f1e589bbf6">is_device3</a> (void)=0</td></tr>
<tr class="separator:a292dcf0faa3d6b5c88cd46f1e589bbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59511a596bc9bd584caf13b0ca38a59"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="classuhd_1_1device3.html">uhd::device3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae59511a596bc9bd584caf13b0ca38a59">get_device3</a> (void)=0</td></tr>
<tr class="separator:ae59511a596bc9bd584caf13b0ca38a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55757381c5114d25f003db7005469fae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55757381c5114d25f003db7005469fae">get_rx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)=0</td></tr>
<tr class="memdesc:a55757381c5114d25f003db7005469fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a RX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>.  <a href="#a55757381c5114d25f003db7005469fae">More...</a><br /></td></tr>
<tr class="separator:a55757381c5114d25f003db7005469fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a0cda6dd9bec82f11d7883d5f2dca4613">get_tx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)=0</td></tr>
<tr class="memdesc:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a TX streamer. See also <a class="el" href="classuhd_1_1device.html#a66d1bf289dd03a03df3860f3eee578c0" title="Make a new transmit streamer from the streamer arguments. ">uhd::device::get_tx_stream()</a>.  <a href="#a0cda6dd9bec82f11d7883d5f2dca4613">More...</a><br /></td></tr>
<tr class="separator:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dadf323c5f00ac4f93b231adc13e34c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1dadf323c5f00ac4f93b231adc13e34c">get_usrp_rx_info</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a1dadf323c5f00ac4f93b231adc13e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b87120ea1f5d9e9d894843a9416578"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af1b87120ea1f5d9e9d894843a9416578">get_usrp_tx_info</a> (size_t chan=0)=0</td></tr>
<tr class="separator:af1b87120ea1f5d9e9d894843a9416578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99254abfa5259b70a020e667eee619b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">set_master_clock_rate</a> (double rate, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a99254abfa5259b70a020e667eee619b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefd7580630b2baa4e4c90df3a36d9f0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:aeefd7580630b2baa4e4c90df3a36d9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d452392111e121e739d0ad6ac6e7c0d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d452392111e121e739d0ad6ac6e7c0d">get_master_clock_rate_range</a> (const size_t mboard=0)=0</td></tr>
<tr class="separator:a1d452392111e121e739d0ad6ac6e7c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22581d58fdf451c3b118add31a6822c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa22581d58fdf451c3b118add31a6822c">get_pp_string</a> (void)=0</td></tr>
<tr class="separator:aa22581d58fdf451c3b118add31a6822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf885b8812408f9ebd471f2902d1cb70"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abf885b8812408f9ebd471f2902d1cb70">get_mboard_name</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:abf885b8812408f9ebd471f2902d1cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4bffe3f969c11ee7c0a2cba5178780"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afb4bffe3f969c11ee7c0a2cba5178780">get_time_now</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:afb4bffe3f969c11ee7c0a2cba5178780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce95415df2de14a048fca5a04ada03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55ce95415df2de14a048fca5a04ada03">get_time_last_pps</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a55ce95415df2de14a048fca5a04ada03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a2c3081944a0d2caab95e2a2f0926"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a351a2c3081944a0d2caab95e2a2f0926">set_time_now</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a351a2c3081944a0d2caab95e2a2f0926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1c5375549e6a446d686ee7d9b4e14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">set_time_next_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a75b1c5375549e6a446d686ee7d9b4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413014bf3aea4a8ea2d268b4a3b390e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a413014bf3aea4a8ea2d268b4a3b390e9">set_time_unknown_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec)=0</td></tr>
<tr class="separator:a413014bf3aea4a8ea2d268b4a3b390e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70237b38918a4b93c37280f6c648b1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acf70237b38918a4b93c37280f6c648b1">get_time_synchronized</a> (void)=0</td></tr>
<tr class="separator:acf70237b38918a4b93c37280f6c648b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b78b00d051d3d51c2f719361c1fb5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a191b78b00d051d3d51c2f719361c1fb5">set_command_time</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a191b78b00d051d3d51c2f719361c1fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607aee766d21228a7aaabde2771eb46f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a607aee766d21228a7aaabde2771eb46f">clear_command_time</a> (size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a607aee766d21228a7aaabde2771eb46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50c2b24273d1b3b2a343b73609b310"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afe50c2b24273d1b3b2a343b73609b310">issue_stream_cmd</a> (const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;stream_cmd, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:afe50c2b24273d1b3b2a343b73609b310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceddf575752fda1a8cc75513a1178fd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aceddf575752fda1a8cc75513a1178fd9">set_clock_config</a> (const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;clock_config, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:aceddf575752fda1a8cc75513a1178fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5580ba06d7d6a037c9ef64f1ea361"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a57a5580ba06d7d6a037c9ef64f1ea361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181262333352a82888af00933d07c3cf"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">get_time_source</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a181262333352a82888af00933d07c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee040da1b7ae375e0c08bb0b080d7ccc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aee040da1b7ae375e0c08bb0b080d7ccc">get_time_sources</a> (const size_t mboard)=0</td></tr>
<tr class="separator:aee040da1b7ae375e0c08bb0b080d7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed40009d0d3787c183d42423d25026"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a73ed40009d0d3787c183d42423d25026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7f679b2f273f7d38eeb1d92e801796"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">get_clock_source</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a1e7f679b2f273f7d38eeb1d92e801796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1022d151717e49ce69c987bd07b243"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3e1022d151717e49ce69c987bd07b243">get_clock_sources</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a3e1022d151717e49ce69c987bd07b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840a47c402b60b3a5d7fd6aac914300"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac840a47c402b60b3a5d7fd6aac914300">set_sync_source</a> (const std::string &amp;clock_source, const std::string &amp;time_source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:ac840a47c402b60b3a5d7fd6aac914300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b94b74c112f76c5b0c1e9e3e77124ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6b94b74c112f76c5b0c1e9e3e77124ce">set_sync_source</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;sync_source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a6b94b74c112f76c5b0c1e9e3e77124ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3ea3ac59b128e8e9e83aeb90b6aa23"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2b3ea3ac59b128e8e9e83aeb90b6aa23">get_sync_source</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a2b3ea3ac59b128e8e9e83aeb90b6aa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc5ed9f9bf41b339a1ae073e624686e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afdc5ed9f9bf41b339a1ae073e624686e">get_sync_sources</a> (const size_t mboard)=0</td></tr>
<tr class="separator:afdc5ed9f9bf41b339a1ae073e624686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60445c1a52e4763b6ebbbfce2db96569"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a60445c1a52e4763b6ebbbfce2db96569">set_clock_source_out</a> (const bool enb, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a60445c1a52e4763b6ebbbfce2db96569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1a4bf21fb32bf761204ce0561b5aa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a1a4bf21fb32bf761204ce0561b5aa7">set_time_source_out</a> (const bool enb, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a3a1a4bf21fb32bf761204ce0561b5aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4efbbc6480fba44939b34c78d44d7e9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4efbbc6480fba44939b34c78d44d7e9">get_num_mboards</a> (void)=0</td></tr>
<tr class="separator:ae4efbbc6480fba44939b34c78d44d7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c327bcb83fd274e05e3ca95d1ac95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">get_mboard_sensor</a> (const std::string &amp;name, size_t mboard=0)=0</td></tr>
<tr class="separator:a2d3c327bcb83fd274e05e3ca95d1ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72259c19b80512dba02e40ed5cf028"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">get_mboard_sensor_names</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a3a72259c19b80512dba02e40ed5cf028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417d8733daa8582957e8de4741ef9ced"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a417d8733daa8582957e8de4741ef9ced">set_user_register</a> (const uint8_t addr, const uint32_t data, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a417d8733daa8582957e8de4741ef9ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8978dc94513414db087e7cb60a009f5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1wb__iface.html#a2369ba0ac501d4b309f181063c13aa3f">uhd::wb_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8978dc94513414db087e7cb60a009f5f">get_user_settings_iface</a> (const size_t chan=0)=0</td></tr>
<tr class="separator:a8978dc94513414db087e7cb60a009f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94ed00059cc7dd30567d031b3f9679"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f94ed00059cc7dd30567d031b3f9679">set_rx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a7f94ed00059cc7dd30567d031b3f9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bacd1b1109656d21da6d5e5f8d417c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8bacd1b1109656d21da6d5e5f8d417c9">get_rx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a8bacd1b1109656d21da6d5e5f8d417c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac94be28eadeccb9c230ce839e072e3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afac94be28eadeccb9c230ce839e072e3">get_rx_num_channels</a> (void)=0</td></tr>
<tr class="separator:afac94be28eadeccb9c230ce839e072e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35004bc7e6d418c2c46b2ca0f34db2e6"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a35004bc7e6d418c2c46b2ca0f34db2e6">get_rx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a35004bc7e6d418c2c46b2ca0f34db2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587cfb5be38a16fec532793b34fbf947"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a587cfb5be38a16fec532793b34fbf947">set_rx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a587cfb5be38a16fec532793b34fbf947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf580742d260257bd7e280666423dc9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9bf580742d260257bd7e280666423dc9">get_rx_rate</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9bf580742d260257bd7e280666423dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4200ca796a8c70737b180087f8f93c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c4200ca796a8c70737b180087f8f93c">get_rx_rates</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a6c4200ca796a8c70737b180087f8f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b61448f392466e20572fdcb042e8ec6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9b61448f392466e20572fdcb042e8ec6">set_rx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr class="separator:a9b61448f392466e20572fdcb042e8ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c803658f18006efc1dcd67de6d493"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#adb1c803658f18006efc1dcd67de6d493">get_rx_freq</a> (size_t chan=0)=0</td></tr>
<tr class="separator:adb1c803658f18006efc1dcd67de6d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ed2146ac31e641839d00a53df784d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9a5ed2146ac31e641839d00a53df784d">get_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9a5ed2146ac31e641839d00a53df784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63a5b45ca3cc3d74db51a384bba8c2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac63a5b45ca3cc3d74db51a384bba8c2e">get_fe_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ac63a5b45ca3cc3d74db51a384bba8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357272d946717da618930d38d11e79e7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a357272d946717da618930d38d11e79e7">get_rx_lo_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a357272d946717da618930d38d11e79e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f1e3d08802842a73e1f0571110335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a865f1e3d08802842a73e1f0571110335">set_rx_lo_source</a> (const std::string &amp;src, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a865f1e3d08802842a73e1f0571110335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6dd6220be2dad3c9ccde7ca6827662"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c6dd6220be2dad3c9ccde7ca6827662">get_rx_lo_source</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a4c6dd6220be2dad3c9ccde7ca6827662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746916a4d9fb60ae745e354b4ae37d14"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a746916a4d9fb60ae745e354b4ae37d14">get_rx_lo_sources</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a746916a4d9fb60ae745e354b4ae37d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1501c36151e4491b014fed8e7bcda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac5c1501c36151e4491b014fed8e7bcda">set_rx_lo_export_enabled</a> (bool enabled, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:ac5c1501c36151e4491b014fed8e7bcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913936cd90ff2be7b659b8b196c4ddf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4913936cd90ff2be7b659b8b196c4ddf">get_rx_lo_export_enabled</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a4913936cd90ff2be7b659b8b196c4ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a2bf7136c0f43b6dcdc51afacbcb5"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b6a2bf7136c0f43b6dcdc51afacbcb5">set_rx_lo_freq</a> (double freq, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a3b6a2bf7136c0f43b6dcdc51afacbcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b262a5a105c3c1babf2017e2c0cf1f8"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b262a5a105c3c1babf2017e2c0cf1f8">get_rx_lo_freq</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a3b262a5a105c3c1babf2017e2c0cf1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4466a2e8fe0779962bbe4bb800511e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4466a2e8fe0779962bbe4bb800511e8">get_rx_lo_freq_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ae4466a2e8fe0779962bbe4bb800511e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f9240384eb1a8a829e3aa7d42134d5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57f9240384eb1a8a829e3aa7d42134d5">get_tx_lo_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a57f9240384eb1a8a829e3aa7d42134d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d2c73c531cee18ea6490fa19cfc92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afa6d2c73c531cee18ea6490fa19cfc92">set_tx_lo_source</a> (const std::string &amp;src, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, const size_t chan=0)=0</td></tr>
<tr class="separator:afa6d2c73c531cee18ea6490fa19cfc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f855adf3dff8dc2e8a6ea9d45eafd"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a824f855adf3dff8dc2e8a6ea9d45eafd">get_tx_lo_source</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, const size_t chan=0)=0</td></tr>
<tr class="separator:a824f855adf3dff8dc2e8a6ea9d45eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe3994da6db41379a213e18b813cd46"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4fe3994da6db41379a213e18b813cd46">get_tx_lo_sources</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, const size_t chan=0)=0</td></tr>
<tr class="separator:a4fe3994da6db41379a213e18b813cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1c9dfa06995d9ec5f3450c42007381"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e1c9dfa06995d9ec5f3450c42007381">set_tx_lo_export_enabled</a> (const bool enabled, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, const size_t chan=0)=0</td></tr>
<tr class="separator:a1e1c9dfa06995d9ec5f3450c42007381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512fb68781b2630865b8fcaef20ac030"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a512fb68781b2630865b8fcaef20ac030">get_tx_lo_export_enabled</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, const size_t chan=0)=0</td></tr>
<tr class="separator:a512fb68781b2630865b8fcaef20ac030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0203de8957159b66fa34c4f61f819c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6e0203de8957159b66fa34c4f61f819c">set_tx_lo_freq</a> (const double freq, const std::string &amp;name, const size_t chan=0)=0</td></tr>
<tr class="separator:a6e0203de8957159b66fa34c4f61f819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3e7b74d2b58c6e664a2be54f77f4ae"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6e3e7b74d2b58c6e664a2be54f77f4ae">get_tx_lo_freq</a> (const std::string &amp;name, const size_t chan=0)=0</td></tr>
<tr class="separator:a6e3e7b74d2b58c6e664a2be54f77f4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7e58808673affe7861a6dbf0e5b7f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7cb7e58808673affe7861a6dbf0e5b7f">get_tx_lo_freq_range</a> (const std::string &amp;name, const size_t chan=0)=0</td></tr>
<tr class="separator:a7cb7e58808673affe7861a6dbf0e5b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602e7681b796deddd9231f022ffef11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">set_rx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ad602e7681b796deddd9231f022ffef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229e085aef20630bdd87b2b4faa036e7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a229e085aef20630bdd87b2b4faa036e7">get_rx_gain_profile_names</a> (const size_t chan=0)=0</td></tr>
<tr class="separator:a229e085aef20630bdd87b2b4faa036e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a73d69712d79f6dbeff970f93153e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a30a73d69712d79f6dbeff970f93153e9">set_rx_gain_profile</a> (const std::string &amp;profile, const size_t chan=0)=0</td></tr>
<tr class="separator:a30a73d69712d79f6dbeff970f93153e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52903f250535f7c1a1846eafa99b29ef"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a52903f250535f7c1a1846eafa99b29ef">get_rx_gain_profile</a> (const size_t chan=0)=0</td></tr>
<tr class="separator:a52903f250535f7c1a1846eafa99b29ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234968ad1fefef299ef9541cc193915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8234968ad1fefef299ef9541cc193915">set_rx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr class="memdesc:a8234968ad1fefef299ef9541cc193915"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall RX gain.  <a href="#a8234968ad1fefef299ef9541cc193915">More...</a><br /></td></tr>
<tr class="separator:a8234968ad1fefef299ef9541cc193915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695b20f1053663669d45669af60f834"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain</a> (double gain, size_t chan=0)=0</td></tr>
<tr class="separator:ab695b20f1053663669d45669af60f834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdab1f6c3775a9071b15c9805f866486"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abdab1f6c3775a9071b15c9805f866486">set_rx_agc</a> (bool enable, size_t chan=0)=0</td></tr>
<tr class="separator:abdab1f6c3775a9071b15c9805f866486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c406b7964f4cc18dc5b57cafcb345c1"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">get_rx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a4c406b7964f4cc18dc5b57cafcb345c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483b85f90a3f46d8181a9b57be1db46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6483b85f90a3f46d8181a9b57be1db46">get_rx_gain</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a6483b85f90a3f46d8181a9b57be1db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain.  <a href="#a6483b85f90a3f46d8181a9b57be1db46">More...</a><br /></td></tr>
<tr class="separator:a6483b85f90a3f46d8181a9b57be1db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7ca6681859b985682afc3f353a0631"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6b7ca6681859b985682afc3f353a0631">get_normalized_rx_gain</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a6b7ca6681859b985682afc3f353a0631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e077fc7331f7675aa796e030bd8a03e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">get_rx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a7e077fc7331f7675aa796e030bd8a03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3245ee320e9889a477ba753fd8b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7eb3245ee320e9889a477ba753fd8b8c">get_rx_gain_range</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a7eb3245ee320e9889a477ba753fd8b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain range.  <a href="#a7eb3245ee320e9889a477ba753fd8b8c">More...</a><br /></td></tr>
<tr class="separator:a7eb3245ee320e9889a477ba753fd8b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496745114d83049ed3d0f5fc96e87b2a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a496745114d83049ed3d0f5fc96e87b2a">get_rx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a496745114d83049ed3d0f5fc96e87b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b7947cb0c434b98e9915f91b8f8fe0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a72b7947cb0c434b98e9915f91b8f8fe0">set_rx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr class="separator:a72b7947cb0c434b98e9915f91b8f8fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d35d85aebebfdd2d14cee2850243af"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad2d35d85aebebfdd2d14cee2850243af">get_rx_antenna</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ad2d35d85aebebfdd2d14cee2850243af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1202c5cc978663182adec8c07d8521"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c1202c5cc978663182adec8c07d8521">get_rx_antennas</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a7c1202c5cc978663182adec8c07d8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e026819f286e69c48c2e1956d95c6fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e026819f286e69c48c2e1956d95c6fb">set_rx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr class="separator:a4e026819f286e69c48c2e1956d95c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7826c7b96aed88c74ffc035b7f0dd"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d7826c7b96aed88c74ffc035b7f0dd">get_rx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a90d7826c7b96aed88c74ffc035b7f0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71672f89943c87a87f03821e5c185c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af71672f89943c87a87f03821e5c185c5">get_rx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:af71672f89943c87a87f03821e5c185c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299d8f77f1d823c762e36438bac509e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3299d8f77f1d823c762e36438bac509e">get_rx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a3299d8f77f1d823c762e36438bac509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd37d327931cec64e3701eb2a5aa7bfb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">get_rx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:acd37d327931cec64e3701eb2a5aa7bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d3d097b6cb1cfa940896e71e5f44ad"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">get_rx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a87d3d097b6cb1cfa940896e71e5f44ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beb49c1a04a81b3e7569db482453746"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7beb49c1a04a81b3e7569db482453746">set_rx_dc_offset</a> (const bool enb, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a7beb49c1a04a81b3e7569db482453746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8212c1131a34823430c9bdec9c183f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8b8212c1131a34823430c9bdec9c183f">set_rx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a8b8212c1131a34823430c9bdec9c183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f60006ffa78099c3447a235b6b9032"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a60f60006ffa78099c3447a235b6b9032">get_rx_dc_offset_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a60f60006ffa78099c3447a235b6b9032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586c52db545664cb2caf830ac90c051e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a586c52db545664cb2caf830ac90c051e">set_rx_iq_balance</a> (const bool enb, size_t chan)=0</td></tr>
<tr class="separator:a586c52db545664cb2caf830ac90c051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd212322a5da010ba79f9f18561156"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7ccd212322a5da010ba79f9f18561156">set_rx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a7ccd212322a5da010ba79f9f18561156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d9d9fb9a1ec51e81a207cd299e517"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b8d9d9fb9a1ec51e81a207cd299e517">set_tx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a3b8d9d9fb9a1ec51e81a207cd299e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070b4bb3cf27436fb9104a414bc9f3f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a070b4bb3cf27436fb9104a414bc9f3f7">get_tx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a070b4bb3cf27436fb9104a414bc9f3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be03eb72575c9d5526c93dd133e96d3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3be03eb72575c9d5526c93dd133e96d3">get_tx_num_channels</a> (void)=0</td></tr>
<tr class="separator:a3be03eb72575c9d5526c93dd133e96d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0632b6ddff26e9d0bd22990274f99d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4b0632b6ddff26e9d0bd22990274f99d">get_tx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a4b0632b6ddff26e9d0bd22990274f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bc17744d3ee94b7c5cdcb75457bd6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab8bc17744d3ee94b7c5cdcb75457bd6b">set_tx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:ab8bc17744d3ee94b7c5cdcb75457bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75c9dd5ad3c9378f079f4950b043dd"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2b75c9dd5ad3c9378f079f4950b043dd">get_tx_rate</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a2b75c9dd5ad3c9378f079f4950b043dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36270e66858e63bd8c887fc127782fb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a36270e66858e63bd8c887fc127782fb5">get_tx_rates</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a36270e66858e63bd8c887fc127782fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a674a9d012a78dd4f2ded478839124"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae7a674a9d012a78dd4f2ded478839124">set_tx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr class="separator:ae7a674a9d012a78dd4f2ded478839124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9b0e10e67d967c06e8dd6511b5919"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9ac9b0e10e67d967c06e8dd6511b5919">get_tx_freq</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9ac9b0e10e67d967c06e8dd6511b5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898502a489319cd64230bb0e50d9ab0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a898502a489319cd64230bb0e50d9ab0a">get_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a898502a489319cd64230bb0e50d9ab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5418609a1d90f8deb21419bf78fec0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad5418609a1d90f8deb21419bf78fec0f">get_fe_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ad5418609a1d90f8deb21419bf78fec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc3c774451d0a2c5f69cd8df0f9f06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">set_tx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a41cc3c774451d0a2c5f69cd8df0f9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103b71b30e95a232d8afdf460263bab4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a103b71b30e95a232d8afdf460263bab4">get_tx_gain_profile_names</a> (const size_t chan=0)=0</td></tr>
<tr class="separator:a103b71b30e95a232d8afdf460263bab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd5ad4102937546593c579157e2be1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7fd5ad4102937546593c579157e2be1d">set_tx_gain_profile</a> (const std::string &amp;profile, const size_t chan=0)=0</td></tr>
<tr class="separator:a7fd5ad4102937546593c579157e2be1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ee84bdc6f30bd8b15691487f8323c3"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa3ee84bdc6f30bd8b15691487f8323c3">get_tx_gain_profile</a> (const size_t chan=0)=0</td></tr>
<tr class="separator:aa3ee84bdc6f30bd8b15691487f8323c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1101dc00b016fe91a299cbcae8b12053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1101dc00b016fe91a299cbcae8b12053">set_tx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr class="memdesc:a1101dc00b016fe91a299cbcae8b12053"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall TX gain.  <a href="#a1101dc00b016fe91a299cbcae8b12053">More...</a><br /></td></tr>
<tr class="separator:a1101dc00b016fe91a299cbcae8b12053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fed2c1b4f34b7c84eb6bb51d189e7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab0fed2c1b4f34b7c84eb6bb51d189e7e">set_normalized_tx_gain</a> (double gain, size_t chan=0)=0</td></tr>
<tr class="separator:ab0fed2c1b4f34b7c84eb6bb51d189e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88320fb12dd6ebfc4b9f6bc4074f11b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">get_tx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ae88320fb12dd6ebfc4b9f6bc4074f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612c00086f9968380bcf51f877b544b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a612c00086f9968380bcf51f877b544b7">get_tx_gain</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a612c00086f9968380bcf51f877b544b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain.  <a href="#a612c00086f9968380bcf51f877b544b7">More...</a><br /></td></tr>
<tr class="separator:a612c00086f9968380bcf51f877b544b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433c396dde24588cece638dd68cb05e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa433c396dde24588cece638dd68cb05e">get_normalized_tx_gain</a> (size_t chan=0)=0</td></tr>
<tr class="separator:aa433c396dde24588cece638dd68cb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99753a578657046f7a0ce72f666abdc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">get_tx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ab99753a578657046f7a0ce72f666abdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6ec9889b9b64d1d8e2a308c0b0c328ec">get_tx_gain_range</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain range.  <a href="#a6ec9889b9b64d1d8e2a308c0b0c328ec">More...</a><br /></td></tr>
<tr class="separator:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5589722a2a1491fc393a6b98f094b0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9f5589722a2a1491fc393a6b98f094b0">get_tx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9f5589722a2a1491fc393a6b98f094b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8cd16aa93bf3375cdcd3daca3b6b24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e8cd16aa93bf3375cdcd3daca3b6b24">set_tx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr class="separator:a4e8cd16aa93bf3375cdcd3daca3b6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3e6094ff76cc3d0630e46cb291bcfd"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f3e6094ff76cc3d0630e46cb291bcfd">get_tx_antenna</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a7f3e6094ff76cc3d0630e46cb291bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b10a6bd2128b3810da229c60b31aa1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a38b10a6bd2128b3810da229c60b31aa1">get_tx_antennas</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a38b10a6bd2128b3810da229c60b31aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bfc300735435a7937d4eb37e5523d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad04bfc300735435a7937d4eb37e5523d">set_tx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr class="separator:ad04bfc300735435a7937d4eb37e5523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd46437f562b8f8f6d4a98cd1c5dc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a227fd46437f562b8f8f6d4a98cd1c5dc">get_tx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a227fd46437f562b8f8f6d4a98cd1c5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebc07fa60f37453a8ac3d6ff2fc7aec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abebc07fa60f37453a8ac3d6ff2fc7aec">get_tx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:abebc07fa60f37453a8ac3d6ff2fc7aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3261f1f763a026707dea80ac466d1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abe3261f1f763a026707dea80ac466d1c">get_tx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr class="separator:abe3261f1f763a026707dea80ac466d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482d52c0983c6db913209e57f9b79c3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">get_tx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a482d52c0983c6db913209e57f9b79c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a556057ceabc00ab2af61525f206fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">get_tx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a33a556057ceabc00ab2af61525f206fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263ab7f0364c03e8a6e330c546769e4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a263ab7f0364c03e8a6e330c546769e4f">set_tx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a263ab7f0364c03e8a6e330c546769e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3171ff467f5f6f71fcfd2db83ce53b3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab3171ff467f5f6f71fcfd2db83ce53b3">get_tx_dc_offset_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ab3171ff467f5f6f71fcfd2db83ce53b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad938e609a11773e21611ee86a0e1b1c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad938e609a11773e21611ee86a0e1b1c5">set_tx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:ad938e609a11773e21611ee86a0e1b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c95bbcd0d62af48852a7048393491"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a5e1c95bbcd0d62af48852a7048393491">get_gpio_banks</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a5e1c95bbcd0d62af48852a7048393491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f25d118d20311aca261e6dd252625e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57f25d118d20311aca261e6dd252625e">set_gpio_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const uint32_t value, const uint32_t mask=0xffffffff, const size_t mboard=0)=0</td></tr>
<tr class="separator:a57f25d118d20311aca261e6dd252625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93eee2ffaf6f96b4c9abb3740614c40b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a93eee2ffaf6f96b4c9abb3740614c40b">set_gpio_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const std::string &amp;value, const uint32_t mask=0xffffffff, const size_t mboard=0)=0</td></tr>
<tr class="separator:a93eee2ffaf6f96b4c9abb3740614c40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445587e23f5b18eef863e310351dbad"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8445587e23f5b18eef863e310351dbad">get_gpio_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const size_t mboard=0)=0</td></tr>
<tr class="separator:a8445587e23f5b18eef863e310351dbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc40e647f3a5de3ef32518e7107bc30"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2bc40e647f3a5de3ef32518e7107bc30">get_gpio_string_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const size_t mboard=0)=0</td></tr>
<tr class="separator:a2bc40e647f3a5de3ef32518e7107bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7306e1067554a655136b24d6e7c2d9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7306e1067554a655136b24d6e7c2d9">enumerate_registers</a> (const size_t mboard=0)=0</td></tr>
<tr class="separator:a1e7306e1067554a655136b24d6e7c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ee2f9b43abe490b293e7de2224aaee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac8ee2f9b43abe490b293e7de2224aaee">get_register_info</a> (const std::string &amp;path, const size_t mboard=0)=0</td></tr>
<tr class="separator:ac8ee2f9b43abe490b293e7de2224aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b729c61604ec4569e1e97b6240ec71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa0b729c61604ec4569e1e97b6240ec71">write_register</a> (const std::string &amp;path, const uint32_t field, const uint64_t value, const size_t mboard=0)=0</td></tr>
<tr class="separator:aa0b729c61604ec4569e1e97b6240ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69a319e44183eac6af490c6da96cc41"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae69a319e44183eac6af490c6da96cc41">read_register</a> (const std::string &amp;path, const uint32_t field, const size_t mboard=0)=0</td></tr>
<tr class="separator:ae69a319e44183eac6af490c6da96cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e7856cd6e01f8eaa4b5936189d874"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names</a> (const std::string &amp;search_mask=&quot;&quot;)=0</td></tr>
<tr class="separator:a574e7856cd6e01f8eaa4b5936189d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab058a3c56d12404c962c4399ecb3ed22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab058a3c56d12404c962c4399ecb3ed22">get_filter</a> (const std::string &amp;path)=0</td></tr>
<tr class="separator:ab058a3c56d12404c962c4399ecb3ed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560768e388cd6494320b72fe9536b0ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a560768e388cd6494320b72fe9536b0ee">set_filter</a> (const std::string &amp;path, <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> filter)=0</td></tr>
<tr class="separator:a560768e388cd6494320b72fe9536b0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0d3809a8f8dcd3c962ad5b9a0a6456c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">make</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;dev_addr)</td></tr>
<tr class="separator:af0d3809a8f8dcd3c962ad5b9a0a6456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a21f2ba01462e1f211a8823fda24a82d5"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></td></tr>
<tr class="memdesc:a21f2ba01462e1f211a8823fda24a82d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard motherboard index.  <a href="#a21f2ba01462e1f211a8823fda24a82d5">More...</a><br /></td></tr>
<tr class="separator:a21f2ba01462e1f211a8823fda24a82d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaca319029cb49f7041461345ab641c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></td></tr>
<tr class="memdesc:afeaca319029cb49f7041461345ab641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard channel index.  <a href="#afeaca319029cb49f7041461345ab641c">More...</a><br /></td></tr>
<tr class="separator:afeaca319029cb49f7041461345ab641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b7e2177492e59382f1124ee32c12b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">ALL_GAINS</a></td></tr>
<tr class="memdesc:a524b7e2177492e59382f1124ee32c12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard gain element name.  <a href="#a524b7e2177492e59382f1124ee32c12b">More...</a><br /></td></tr>
<tr class="separator:a524b7e2177492e59382f1124ee32c12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></td></tr>
<tr class="memdesc:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard LO stage name.  <a href="#a1d5eaa4fb855a52aa97c328ec2fa387b">More...</a><br /></td></tr>
<tr class="separator:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Multi-USRP device class:</p>
<p>This class facilitates ease-of-use for most use-case scenarios. The wrapper provides convenience functions to tune the devices, set the dboard gains, antennas, filters, and other properties. This class can be used to interface with a single USRP with one or more channels, or multiple USRPs in a homogeneous setup. All members take an optional parameter for board number or channel number. In the single device, single channel case, these parameters can be unspecified.</p>
<p>When using a single device with multiple channels:</p><ul>
<li>Channel mapping is determined by the frontend specifications</li>
<li>All channels share a common RX sample rate</li>
<li>All channels share a common TX sample rate</li>
</ul>
<p>When using multiple devices in a configuration:</p><ul>
<li>Channel mapping is determined by the device address arguments</li>
<li>All boards share a common RX sample rate</li>
<li>All boards share a common TX sample rate</li>
<li>All boards share a common RX frontend specification size</li>
<li>All boards share a common TX frontend specification size</li>
<li>All boards must have synchronized times (see the set_time_*() calls)</li>
</ul>
<p>Example to setup channel mapping for multiple devices: </p><pre></pre><pre>//create a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> with two boards in the configuration
<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> dev_addr;
dev_addr["addr0"] = "192.168.10.2"
dev_addr["addr1"] = "192.168.10.3";
<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">multi_usrp::sptr</a> dev = multi_usrp::make(dev_addr);</pre><pre>//set the board on 10.2 to use the A RX frontend (RX channel 0)
dev-&gt;set_rx_subdev_spec("A:A", 0);</pre><pre>//set the board on 10.3 to use the B RX frontend (RX channel 1)
dev-&gt;set_rx_subdev_spec("A:B", 1);</pre><pre>//set both boards to use the AB TX frontend (TX channels 0 and 1)
dev-&gt;set_tx_subdev_spec("A:AB", <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5" title="A wildcard motherboard index. ">multi_usrp::ALL_MBOARDS</a>);</pre><pre>//now that all the channels are mapped, continue with configuration...</pre><pre></pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9d9112f5eac0b53a721f2a6c97021fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9112f5eac0b53a721f2a6c97021fc1">&#9670;&nbsp;</a></span>sptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">uhd::usrp::multi_usrp::sptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6c904057108e52d685b27496a11518db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c904057108e52d685b27496a11518db">&#9670;&nbsp;</a></span>~multi_usrp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uhd::usrp::multi_usrp::~multi_usrp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a607aee766d21228a7aaabde2771eb46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607aee766d21228a7aaabde2771eb46f">&#9670;&nbsp;</a></span>clear_command_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::clear_command_time </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the command time so future commands are sent ASAP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e7306e1067554a655136b24d6e7c2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7306e1067554a655136b24d6e7c2d9">&#9670;&nbsp;</a></span>enumerate_registers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::enumerate_registers </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate the full paths of all low-level USRP registers accessible to read/write </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of register paths </dd></dl>

</div>
</div>
<a id="a1e7f679b2f273f7d38eeb1d92e801796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7f679b2f273f7d38eeb1d92e801796">&#9670;&nbsp;</a></span>get_clock_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_clock_source </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set clock source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representing the clock source </dd></dl>

</div>
</div>
<a id="a3e1022d151717e49ce69c987bd07b243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1022d151717e49ce69c987bd07b243">&#9670;&nbsp;</a></span>get_clock_sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_clock_sources </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible clock sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a id="ac425be38f8e2a3463de440e1f2ae1b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac425be38f8e2a3463de440e1f2ae1b6d">&#9670;&nbsp;</a></span>get_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a> uhd::usrp::multi_usrp::get_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the underlying device object. This is needed to get access to the streaming API and properties. </p><dl class="section return"><dt>Returns</dt><dd>the device object within this USRP </dd></dl>

</div>
</div>
<a id="ae59511a596bc9bd584caf13b0ca38a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59511a596bc9bd584caf13b0ca38a59">&#9670;&nbsp;</a></span>get_device3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="classuhd_1_1device3.html">uhd::device3</a>&gt; uhd::usrp::multi_usrp::get_device3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the underlying <a class="el" href="classuhd_1_1device3.html" title="Extends uhd::device for third-generation USRP devices. ">device3</a> object. Only works for generation-3 (or later) devices.</p>
<p>This is needed to get access to the streaming API and properties.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classuhd_1_1device3.html" title="Extends uhd::device for third-generation USRP devices. ">uhd::device3</a> object for this USRP. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1type__error.html">uhd::type_error</a></td><td>if this device is not actually a generation-3 device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac63a5b45ca3cc3d74db51a384bba8c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63a5b45ca3cc3d74db51a384bba8c2e">&#9670;&nbsp;</a></span>get_fe_rx_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_fe_rx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the center frequency range of the RF frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="ad5418609a1d90f8deb21419bf78fec0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5418609a1d90f8deb21419bf78fec0f">&#9670;&nbsp;</a></span>get_fe_tx_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_fe_tx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the center frequency range of the TX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="ab058a3c56d12404c962c4399ecb3ed22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab058a3c56d12404c962c4399ecb3ed22">&#9670;&nbsp;</a></span>get_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> uhd::usrp::multi_usrp::get_filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the filter object for the given name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the name of the filter as returned from <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>. </dd></dl>

</div>
</div>
<a id="a574e7856cd6e01f8eaa4b5936189d874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574e7856cd6e01f8eaa4b5936189d874">&#9670;&nbsp;</a></span>get_filter_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_filter_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search_mask</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate the available filters in the signal path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_mask</td><td><p class="starttd">Select only certain filter names by specifying this search mask.</p>
<p class="endtd">E.g. if search mask is set to "rx_frontends/A" only filter names including that string will be returned.</p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings representing the selected filter names. </dd></dl>

</div>
</div>
<a id="a8445587e23f5b18eef863e310351dbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8445587e23f5b18eef863e310351dbad">&#9670;&nbsp;</a></span>get_gpio_attr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t uhd::usrp::multi_usrp::get_gpio_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>CTRL - 1 for ATR mode 0 for GPIO mode</li>
<li>DDR - 1 for output 0 for input</li>
<li>OUT - GPIO output level (not ATR mode)</li>
<li>ATR_0X - ATR idle state</li>
<li>ATR_RX - ATR receive only state</li>
<li>ATR_TX - ATR transmit only state</li>
<li>ATR_XX - ATR full duplex state</li>
<li>READBACK - readback input GPIOs <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value set for this attribute </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a5e1c95bbcd0d62af48852a7048393491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1c95bbcd0d62af48852a7048393491">&#9670;&nbsp;</a></span>get_gpio_banks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_gpio_banks </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate gpio banks on the specified device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of string for each bank name </dd></dl>

</div>
</div>
<a id="a2bc40e647f3a5de3ef32518e7107bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc40e647f3a5de3ef32518e7107bc30">&#9670;&nbsp;</a></span>get_gpio_string_attr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_gpio_string_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>SRC - "PS" for handling by processing system<ul>
<li>"RADIO_N/M" for handling by radio block with N is in [0..Number of Radio]; M is in [0..Number of port per Radio]</li>
</ul>
</li>
<li>CTRL - "ATR" for ATR mode<ul>
<li>"GPIO" for GPIO mode</li>
</ul>
</li>
<li>DDR - "OUT" for output<ul>
<li>"IN" for input</li>
</ul>
</li>
<li>OUT - a string of numbers representing GPIO output level (not ATR mode)<ul>
<li>"HIGH"or "LOW" as GPIO output level that apply for each bit mask that is 1</li>
</ul>
</li>
<li>ATR_0X - a string of numbers representing a value of the ATR idle state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR idle state register</li>
</ul>
</li>
<li>ATR_RX - a string of numbers representing a value of a ATR receive only state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR receive only state register</li>
</ul>
</li>
<li>ATR_TX - a string of numbers representing a value of the ATR transmit only state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR transmit only state register</li>
</ul>
</li>
<li>ATR_XX - a string of numbers representing a value of the ATR full duplex state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR full duplex state register</li>
</ul>
</li>
<li>READBACK - readback input GPIOs <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value set for this attribute in vector of strings </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aeefd7580630b2baa4e4c90df3a36d9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefd7580630b2baa4e4c90df3a36d9f0">&#9670;&nbsp;</a></span>get_master_clock_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the master clock rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the master clock rate in Hz. </dd></dl>

</div>
</div>
<a id="a1d452392111e121e739d0ad6ac6e7c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d452392111e121e739d0ad6ac6e7c0d">&#9670;&nbsp;</a></span>get_master_clock_rate_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_master_clock_rate_range </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the range within which the master clock rate can be set for this session</p>
<p>Note that many USRPs do not actually support setting the master clock rate during a running session. In this case, the range will consist of a single value, which is the current master clock rate. Values from this range are valid/sensible inputs to <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">set_master_clock_rate()</a>, although keep in mind that the latter coerces.</p>
<p>Examples:</p><ul>
<li>The B200 series' master clock rate can be changed at runtime and will report the true range of supported values</li>
<li>The X300 series has <em>two</em> discrete options for the clock rate, but will always return the clock rate which the USRP was initialized to because it cannot be changed at runtime</li>
<li>The N200 series does not have a configurable clock rate, and will always return the same single value as a range </li>
</ul>

</div>
</div>
<a id="abf885b8812408f9ebd471f2902d1cb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf885b8812408f9ebd471f2902d1cb70">&#9670;&nbsp;</a></span>get_mboard_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_mboard_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get canonical name for this USRP motherboard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representing the name </dd></dl>

</div>
</div>
<a id="a2d3c327bcb83fd274e05e3ca95d1ac95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c327bcb83fd274e05e3ca95d1ac95">&#9670;&nbsp;</a></span>get_mboard_sensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_mboard_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a motherboard sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a id="a3a72259c19b80512dba02e40ed5cf028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a72259c19b80512dba02e40ed5cf028">&#9670;&nbsp;</a></span>get_mboard_sensor_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_mboard_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible motherboard sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a id="a6b7ca6681859b985682afc3f353a0631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7ca6681859b985682afc3f353a0631">&#9670;&nbsp;</a></span>get_normalized_rx_gain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_normalized_rx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalized RX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion of normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized gain (in [0, 1]) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa433c396dde24588cece638dd68cb05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa433c396dde24588cece638dd68cb05e">&#9670;&nbsp;</a></span>get_normalized_tx_gain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_normalized_tx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalized TX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion of normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized gain (in [0, 1]) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4efbbc6480fba44939b34c78d44d7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4efbbc6480fba44939b34c78d44d7e9">&#9670;&nbsp;</a></span>get_num_mboards()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_num_mboards </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of USRP motherboards in this configuration. </p>

</div>
</div>
<a id="aa22581d58fdf451c3b118add31a6822c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22581d58fdf451c3b118add31a6822c">&#9670;&nbsp;</a></span>get_pp_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_pp_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a printable summary for this USRP configuration. </p><dl class="section return"><dt>Returns</dt><dd>a printable string </dd></dl>

</div>
</div>
<a id="ac8ee2f9b43abe490b293e7de2224aaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ee2f9b43abe490b293e7de2224aaee">&#9670;&nbsp;</a></span>get_register_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a> uhd::usrp::multi_usrp::get_register_info </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get more information about a low-level device register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the info struct which contains the bitwidth and read-write access information </dd></dl>

</div>
</div>
<a id="ad2d35d85aebebfdd2d14cee2850243af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d35d85aebebfdd2d14cee2850243af">&#9670;&nbsp;</a></span>get_rx_antenna()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the selected RX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antenna name </dd></dl>

</div>
</div>
<a id="a7c1202c5cc978663182adec8c07d8521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1202c5cc978663182adec8c07d8521">&#9670;&nbsp;</a></span>get_rx_antennas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible RX antennas on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a id="a90d7826c7b96aed88c74ffc035b7f0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d7826c7b96aed88c74ffc035b7f0dd">&#9670;&nbsp;</a></span>get_rx_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a id="af71672f89943c87a87f03821e5c185c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71672f89943c87a87f03821e5c185c5">&#9670;&nbsp;</a></span>get_rx_bandwidth_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_rx_bandwidth_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the range of the possible RX bandwidth settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a id="a3299d8f77f1d823c762e36438bac509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3299d8f77f1d823c762e36438bac509e">&#9670;&nbsp;</a></span>get_rx_dboard_iface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_rx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dboard interface object for the RX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a id="a60f60006ffa78099c3447a235b6b9032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f60006ffa78099c3447a235b6b9032">&#9670;&nbsp;</a></span>get_rx_dc_offset_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_rx_dc_offset_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the valid range for RX DC offset values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb1c803658f18006efc1dcd67de6d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c803658f18006efc1dcd67de6d493">&#9670;&nbsp;</a></span>get_rx_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a id="a9a5ed2146ac31e641839d00a53df784d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5ed2146ac31e641839d00a53df784d">&#9670;&nbsp;</a></span>get_rx_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_rx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX center frequency range. This range includes the overall tunable range of the RX chain, including frontend chain and digital down conversion chain. This tunable limit does not include the baseband bandwidth; users should assume that the actual range is +/- samp_rate/2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="a4c406b7964f4cc18dc5b57cafcb345c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c406b7964f4cc18dc5b57cafcb345c1">&#9670;&nbsp;</a></span>get_rx_gain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX gain value for the specified gain element. For an empty name, sum across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a id="a6483b85f90a3f46d8181a9b57be1db46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483b85f90a3f46d8181a9b57be1db46">&#9670;&nbsp;</a></span>get_rx_gain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall RX gain. </p>

</div>
</div>
<a id="a496745114d83049ed3d0f5fc96e87b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496745114d83049ed3d0f5fc96e87b2a">&#9670;&nbsp;</a></span>get_rx_gain_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the names of the gain elements in the RX chain. Gain elements are ordered from antenna to FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a id="a52903f250535f7c1a1846eafa99b29ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52903f250535f7c1a1846eafa99b29ef">&#9670;&nbsp;</a></span>get_rx_gain_profile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_gain_profile </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX gain profile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string of current RX gain profile of corresponding channel. </dd></dl>

</div>
</div>
<a id="a229e085aef20630bdd87b2b4faa036e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229e085aef20630bdd87b2b4faa036e7">&#9670;&nbsp;</a></span>get_rx_gain_profile_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_gain_profile_names </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible RX gain profile options</p>
<p>Example: On the TwinRX, this will return "low-noise", "low-distortion" or "default". These names can be used in gain-profile related API called. An empty return value doesn't mean there are no profile options, it means that this radio does not have any gain profiles implemented, and typically means there is only one default profile of set gain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible gain profile options, or an empty list of this doesn't apply. </dd></dl>

</div>
</div>
<a id="a7e077fc7331f7675aa796e030bd8a03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e077fc7331f7675aa796e030bd8a03e">&#9670;&nbsp;</a></span>get_rx_gain_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a gain range object </dd></dl>

</div>
</div>
<a id="a7eb3245ee320e9889a477ba753fd8b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb3245ee320e9889a477ba753fd8b8c">&#9670;&nbsp;</a></span>get_rx_gain_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall RX gain range. </p>

</div>
</div>
<a id="a4913936cd90ff2be7b659b8b196c4ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4913936cd90ff2be7b659b8b196c4ddf">&#9670;&nbsp;</a></span>get_rx_lo_export_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_rx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the currently selected LO is being exported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b262a5a105c3c1babf2017e2c0cf1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b262a5a105c3c1babf2017e2c0cf1f8">&#9670;&nbsp;</a></span>get_rx_lo_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current RX LO frequency (Advanced).</p>
<p>If the channel does not have independently configurable LOs the current rf frequency will be returned. See also <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b6a2bf7136c0f43b6dcdc51afacbcb5">set_rx_lo_freq()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO frequency </dd></dl>

</div>
</div>
<a id="ae4466a2e8fe0779962bbe4bb800511e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4466a2e8fe0779962bbe4bb800511e8">&#9670;&nbsp;</a></span>get_rx_lo_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_rx_lo_freq_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the LO frequency range of the RX LO.</p>
<p>If the channel does not have independently configurable LOs the rf frequency range will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="a357272d946717da618930d38d11e79e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357272d946717da618930d38d11e79e7">&#9670;&nbsp;</a></span>get_rx_lo_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_lo_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible LO stage names</p>
<p>Example: On the TwinRX, this will return "LO1", "LO2". These names can are used in other LO-related API calls, so this function can be used for automatically enumerating LO stages. An empty return value doesn't mean there are no LOs, it means that this radio does not have an LO API implemented, and typically means the LOs have no direct way of being controlled other than setting the frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible LO names, or an empty list of this doesn't apply (i.e. there are no controllable LO stages) </dd></dl>

</div>
</div>
<a id="a4c6dd6220be2dad3c9ccde7ca6827662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6dd6220be2dad3c9ccde7ca6827662">&#9670;&nbsp;</a></span>get_rx_lo_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string uhd::usrp::multi_usrp::get_rx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently selected LO source.</p>
<p>Channels without controllable LO sources will always return "internal".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO source </dd></dl>

</div>
</div>
<a id="a746916a4d9fb60ae745e354b4ae37d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746916a4d9fb60ae745e354b4ae37d14">&#9670;&nbsp;</a></span>get_rx_lo_sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_lo_sources </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible LO sources.</p>
<p>Channels which do not have controllable LO sources will return "internal". Typical values are "internal" and "external", although the TwinRX has more options, such as "companion". These options are device- specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a id="afac94be28eadeccb9c230ce839e072e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac94be28eadeccb9c230ce839e072e3">&#9670;&nbsp;</a></span>get_rx_num_channels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_rx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of RX channels in this configuration. This is the number of USRPs times the number of RX channels per board, where the number of RX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a id="a9bf580742d260257bd7e280666423dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf580742d260257bd7e280666423dc9">&#9670;&nbsp;</a></span>get_rx_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the RX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a id="a6c4200ca796a8c70737b180087f8f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4200ca796a8c70737b180087f8f93c">&#9670;&nbsp;</a></span>get_rx_rates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_rx_rates </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a range of possible RX rates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a id="acd37d327931cec64e3701eb2a5aa7bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd37d327931cec64e3701eb2a5aa7bfb">&#9670;&nbsp;</a></span>get_rx_sensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_rx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an RX frontend sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a id="a87d3d097b6cb1cfa940896e71e5f44ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d3d097b6cb1cfa940896e71e5f44ad">&#9670;&nbsp;</a></span>get_rx_sensor_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible RX frontend sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a id="a55757381c5114d25f003db7005469fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55757381c5114d25f003db7005469fae">&#9670;&nbsp;</a></span>get_rx_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a> uhd::usrp::multi_usrp::get_rx_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get a RX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>. </p>

</div>
</div>
<a id="a35004bc7e6d418c2c46b2ca0f34db2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35004bc7e6d418c2c46b2ca0f34db2e6">&#9670;&nbsp;</a></span>get_rx_subdev_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the RX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend name </dd></dl>

</div>
</div>
<a id="a8bacd1b1109656d21da6d5e5f8d417c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bacd1b1109656d21da6d5e5f8d417c9">&#9670;&nbsp;</a></span>get_rx_subdev_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX frontend specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a id="a2b3ea3ac59b128e8e9e83aeb90b6aa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3ea3ac59b128e8e9e83aeb90b6aa23">&#9670;&nbsp;</a></span>get_sync_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> uhd::usrp::multi_usrp::get_sync_source </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set sync source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dictionary representing the sync source settings </dd></dl>

</div>
</div>
<a id="afdc5ed9f9bf41b339a1ae073e624686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc5ed9f9bf41b339a1ae073e624686e">&#9670;&nbsp;</a></span>get_sync_sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a>&gt; uhd::usrp::multi_usrp::get_sync_sources </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of available sync sources</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dictionary representing the sync source settings </dd></dl>

</div>
</div>
<a id="a55ce95415df2de14a048fca5a04ada03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ce95415df2de14a048fca5a04ada03">&#9670;&nbsp;</a></span>get_time_last_pps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_last_pps </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the time when the last pps pulse occurred. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timespec representing the last pps </dd></dl>

</div>
</div>
<a id="afb4bffe3f969c11ee7c0a2cba5178780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4bffe3f969c11ee7c0a2cba5178780">&#9670;&nbsp;</a></span>get_time_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_now </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current time in the usrp time registers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timespec representing current usrp time </dd></dl>

</div>
</div>
<a id="a181262333352a82888af00933d07c3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181262333352a82888af00933d07c3cf">&#9670;&nbsp;</a></span>get_time_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_time_source </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set time source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representing the time source </dd></dl>

</div>
</div>
<a id="aee040da1b7ae375e0c08bb0b080d7ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee040da1b7ae375e0c08bb0b080d7ccc">&#9670;&nbsp;</a></span>get_time_sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_time_sources </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible time sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a id="acf70237b38918a4b93c37280f6c648b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf70237b38918a4b93c37280f6c648b1">&#9670;&nbsp;</a></span>get_time_synchronized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_time_synchronized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Are the times across all motherboards in this configuration synchronized? Checks that all time registers are approximately close but not exact, given that the RTT may varying for a control packet transaction. </p><dl class="section return"><dt>Returns</dt><dd>true when all motherboards time registers are in sync </dd></dl>

</div>
</div>
<a id="a7f3e6094ff76cc3d0630e46cb291bcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3e6094ff76cc3d0630e46cb291bcfd">&#9670;&nbsp;</a></span>get_tx_antenna()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the selected TX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antenna name </dd></dl>

</div>
</div>
<a id="a38b10a6bd2128b3810da229c60b31aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b10a6bd2128b3810da229c60b31aa1">&#9670;&nbsp;</a></span>get_tx_antennas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX antennas on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a id="a227fd46437f562b8f8f6d4a98cd1c5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227fd46437f562b8f8f6d4a98cd1c5dc">&#9670;&nbsp;</a></span>get_tx_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a id="abebc07fa60f37453a8ac3d6ff2fc7aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebc07fa60f37453a8ac3d6ff2fc7aec">&#9670;&nbsp;</a></span>get_tx_bandwidth_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_tx_bandwidth_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the range of the possible TX bandwidth settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a id="abe3261f1f763a026707dea80ac466d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3261f1f763a026707dea80ac466d1c">&#9670;&nbsp;</a></span>get_tx_dboard_iface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_tx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dboard interface object for the TX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a id="ab3171ff467f5f6f71fcfd2db83ce53b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3171ff467f5f6f71fcfd2db83ce53b3">&#9670;&nbsp;</a></span>get_tx_dc_offset_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_tx_dc_offset_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the valid range for TX DC offset values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac9b0e10e67d967c06e8dd6511b5919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac9b0e10e67d967c06e8dd6511b5919">&#9670;&nbsp;</a></span>get_tx_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a id="a898502a489319cd64230bb0e50d9ab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898502a489319cd64230bb0e50d9ab0a">&#9670;&nbsp;</a></span>get_tx_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_tx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX center frequency range. This range includes the overall tunable range of the TX chain, including frontend chain and digital up conversion chain. This tunable limit does not include the baseband bandwidth; users should assume that the actual range is +/- samp_rate/2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="ae88320fb12dd6ebfc4b9f6bc4074f11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88320fb12dd6ebfc4b9f6bc4074f11b">&#9670;&nbsp;</a></span>get_tx_gain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX gain value for the specified gain element. For an empty name, sum across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a id="a612c00086f9968380bcf51f877b544b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612c00086f9968380bcf51f877b544b7">&#9670;&nbsp;</a></span>get_tx_gain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall TX gain. </p>

</div>
</div>
<a id="a9f5589722a2a1491fc393a6b98f094b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5589722a2a1491fc393a6b98f094b0">&#9670;&nbsp;</a></span>get_tx_gain_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the names of the gain elements in the TX chain. Gain elements are ordered from antenna to FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a id="aa3ee84bdc6f30bd8b15691487f8323c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ee84bdc6f30bd8b15691487f8323c3">&#9670;&nbsp;</a></span>get_tx_gain_profile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_gain_profile </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX gain profile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string of current TX gain profile of corresponding channel. </dd></dl>

</div>
</div>
<a id="a103b71b30e95a232d8afdf460263bab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103b71b30e95a232d8afdf460263bab4">&#9670;&nbsp;</a></span>get_tx_gain_profile_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_gain_profile_names </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX gain profile options</p>
<p>Example: On the N310, this will return "manual" or "default". These names can be used in gain related API called. An empty return value doesn't mean there are no profile options, it means that this radio does not have any gain profiles implemented, and typically means there is only one default profile of set gain</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible gain profile options, or an empty list of this doesn't apply. </dd></dl>

</div>
</div>
<a id="ab99753a578657046f7a0ce72f666abdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99753a578657046f7a0ce72f666abdc">&#9670;&nbsp;</a></span>get_tx_gain_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a gain range object </dd></dl>

</div>
</div>
<a id="a6ec9889b9b64d1d8e2a308c0b0c328ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec9889b9b64d1d8e2a308c0b0c328ec">&#9670;&nbsp;</a></span>get_tx_gain_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall TX gain range. </p>

</div>
</div>
<a id="a512fb68781b2630865b8fcaef20ac030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512fb68781b2630865b8fcaef20ac030">&#9670;&nbsp;</a></span>get_tx_lo_export_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_tx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the currently selected LO is being exported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e3e7b74d2b58c6e664a2be54f77f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3e7b74d2b58c6e664a2be54f77f4ae">&#9670;&nbsp;</a></span>get_tx_lo_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current TX LO frequency (Advanced).</p>
<p>If the channel does not have independently configurable LOs the current rf frequency will be returned. See also <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6e0203de8957159b66fa34c4f61f819c">set_tx_lo_freq()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO frequency </dd></dl>

</div>
</div>
<a id="a7cb7e58808673affe7861a6dbf0e5b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb7e58808673affe7861a6dbf0e5b7f">&#9670;&nbsp;</a></span>get_tx_lo_freq_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_tx_lo_freq_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the LO frequency range of the TX LO.</p>
<p>If the channel does not have independently configurable LOs the rf frequency range will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a id="a57f9240384eb1a8a829e3aa7d42134d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f9240384eb1a8a829e3aa7d42134d5">&#9670;&nbsp;</a></span>get_tx_lo_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_lo_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX LO stage names</p>
<p>See also <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a357272d946717da618930d38d11e79e7">get_rx_lo_names()</a>.</p>
<p>An empty return value doesn't mean there are no LOs, it means that this radio does not have an LO API implemented, and typically means the LOs have no direct way of being controlled other than setting the frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible LO names, or an empty list of this doesn't apply (i.e. there are no controllable LO stages) </dd></dl>

</div>
</div>
<a id="a824f855adf3dff8dc2e8a6ea9d45eafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824f855adf3dff8dc2e8a6ea9d45eafd">&#9670;&nbsp;</a></span>get_tx_lo_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string uhd::usrp::multi_usrp::get_tx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently selected TX LO source.</p>
<p>Channels without controllable LO sources will always return "internal".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO source </dd></dl>

</div>
</div>
<a id="a4fe3994da6db41379a213e18b813cd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe3994da6db41379a213e18b813cd46">&#9670;&nbsp;</a></span>get_tx_lo_sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_lo_sources </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible LO sources.</p>
<p>Channels which do not have controllable LO sources will return "internal". Typical values are "internal" and "external". These options are device-specific.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a id="a3be03eb72575c9d5526c93dd133e96d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be03eb72575c9d5526c93dd133e96d3">&#9670;&nbsp;</a></span>get_tx_num_channels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_tx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of TX channels in this configuration. This is the number of USRPs times the number of TX channels per board, where the number of TX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a id="a2b75c9dd5ad3c9378f079f4950b043dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b75c9dd5ad3c9378f079f4950b043dd">&#9670;&nbsp;</a></span>get_tx_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the TX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a id="a36270e66858e63bd8c887fc127782fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36270e66858e63bd8c887fc127782fb5">&#9670;&nbsp;</a></span>get_tx_rates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_tx_rates </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a range of possible TX rates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a id="a482d52c0983c6db913209e57f9b79c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482d52c0983c6db913209e57f9b79c3a">&#9670;&nbsp;</a></span>get_tx_sensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_tx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an TX frontend sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a id="a33a556057ceabc00ab2af61525f206fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a556057ceabc00ab2af61525f206fd">&#9670;&nbsp;</a></span>get_tx_sensor_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX frontend sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a id="a0cda6dd9bec82f11d7883d5f2dca4613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cda6dd9bec82f11d7883d5f2dca4613">&#9670;&nbsp;</a></span>get_tx_stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a> uhd::usrp::multi_usrp::get_tx_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get a TX streamer. See also <a class="el" href="classuhd_1_1device.html#a66d1bf289dd03a03df3860f3eee578c0" title="Make a new transmit streamer from the streamer arguments. ">uhd::device::get_tx_stream()</a>. </p>

</div>
</div>
<a id="a4b0632b6ddff26e9d0bd22990274f99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0632b6ddff26e9d0bd22990274f99d">&#9670;&nbsp;</a></span>get_tx_subdev_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the TX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend name </dd></dl>

</div>
</div>
<a id="a070b4bb3cf27436fb9104a414bc9f3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070b4bb3cf27436fb9104a414bc9f3f7">&#9670;&nbsp;</a></span>get_tx_subdev_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX frontend specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a id="a8978dc94513414db087e7cb60a009f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8978dc94513414db087e7cb60a009f5f">&#9670;&nbsp;</a></span>get_user_settings_iface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1wb__iface.html#a2369ba0ac501d4b309f181063c13aa3f">uhd::wb_iface::sptr</a> uhd::usrp::multi_usrp::get_user_settings_iface </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a user settings interface object</p>
<p>This is only supported by some USRPs (B2xx series, N230). It will return an object that will allow to peek and poke user settings, which typically are implemented by custom FPGA images. If the device does not support such an interface, it will return a null pointer. This allows to probe this functionality, but can lead to dereferencing errors if no checks are performed.</p>
<p>A typical way to use this is as follows: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">multi_usrp::make</a>(device_args);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> chan = 0;</div><div class="line"><span class="keyword">auto</span> user_settings = usrp-&gt;get_user_settings_iface(chan);</div><div class="line"><span class="keywordflow">if</span> (!user_settings) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;No user settings!&quot;</span> &lt;&lt; std::endl;</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">    user_settings-&gt;poke32(0, 23); <span class="comment">// Write value 23 to register 0</span></div><div class="line">}</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Either a <a class="el" href="classuhd_1_1wb__iface.html">uhd::wb_iface</a> object to poke the user settings, or a nullptr if the device doesn't support this interface. </dd></dl>

</div>
</div>
<a id="a1dadf323c5f00ac4f93b231adc13e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dadf323c5f00ac4f93b231adc13e34c">&#9670;&nbsp;</a></span>get_usrp_rx_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; uhd::usrp::multi_usrp::get_usrp_rx_info </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard RX ID, subdev name and spec, serial, and antenna. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX info </dd></dl>

</div>
</div>
<a id="af1b87120ea1f5d9e9d894843a9416578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b87120ea1f5d9e9d894843a9416578">&#9670;&nbsp;</a></span>get_usrp_tx_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; uhd::usrp::multi_usrp::get_usrp_tx_info </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard TX ID, subdev name and spec, serial, and antenna. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX info </dd></dl>

</div>
</div>
<a id="a292dcf0faa3d6b5c88cd46f1e589bbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292dcf0faa3d6b5c88cd46f1e589bbf6">&#9670;&nbsp;</a></span>is_device3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::is_device3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this is a generation-3 device. </p>

</div>
</div>
<a id="afe50c2b24273d1b3b2a343b73609b310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe50c2b24273d1b3b2a343b73609b310">&#9670;&nbsp;</a></span>issue_stream_cmd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::issue_stream_cmd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>stream_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Issue a stream command to the usrp device. This tells the usrp to send samples into the host. See the documentation for <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> for more info.</p>
<p>With multiple devices, the first stream command in a chain of commands should have a time spec in the near future and stream_now = false; to ensure that the packets can be aligned by their time specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_cmd</td><td>the stream command to issue </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0d3809a8f8dcd3c962ad5b9a0a6456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d3809a8f8dcd3c962ad5b9a0a6456c">&#9670;&nbsp;</a></span>make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a> uhd::usrp::multi_usrp::make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a new multi usrp from the device address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_addr</td><td>the device address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new single usrp object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1key__error.html">uhd::key_error</a></td><td>no device found </td></tr>
    <tr><td class="paramname"><a class="el" href="structuhd_1_1index__error.html">uhd::index_error</a></td><td>fewer devices found than expected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae69a319e44183eac6af490c6da96cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69a319e44183eac6af490c6da96cc41">&#9670;&nbsp;</a></span>read_register()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t uhd::usrp::multi_usrp::read_register </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a low-level register field from a register in the USRP hardware </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">field</td><td>the identifier of bitfield to be read </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the register field </dd></dl>

</div>
</div>
<a id="aceddf575752fda1a8cc75513a1178fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceddf575752fda1a8cc75513a1178fd9">&#9670;&nbsp;</a></span>set_clock_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;&#160;</td>
          <td class="paramname"><em>clock_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the clock configuration for the usrp device. DEPRECATED in favor of set time and clock source calls. This tells the usrp how to get a 10MHz reference and PPS clock. See the documentation for <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_config</td><td>the clock configuration to set </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ed40009d0d3787c183d42423d25026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ed40009d0d3787c183d42423d25026">&#9670;&nbsp;</a></span>set_clock_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the clock source for the USRP device</p>
<p>This sets the source of the frequency reference, typically a 10 MHz signal. In order to frequency-align multiple USRPs, it is necessary to connect all of them to a common reference and provide them with the same clock source. Typical values for <code>source</code> are 'internal', 'external'. Refer to the specific device manual for a full list of options.</p>
<p>If the value for for <code>source</code> is not available for this device, it will throw an exception. Calling <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3e1022d151717e49ce69c987bd07b243">get_clock_sources()</a> will return a valid list of options for this method.</p>
<p>Side effects: Some devices only support certain combinations of time and clock source. It is possible that the underlying device implementation will change the time source when the clock source changes and vice versa. Reading back the current values of clock and time source using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">get_clock_source()</a> and <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">get_time_source()</a> is the only certain way of knowing which clock and time source are currently selected.</p>
<p>This function does not force a re-initialization of the underlying hardware when the value does not change. Consider the following snippet: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(device_args);</div><div class="line"><span class="comment">// This may or may not cause the hardware to reconfigure, depending on</span></div><div class="line"><span class="comment">// the default state of the device</span></div><div class="line">usrp-&gt;set_clock_source(<span class="stringliteral">&quot;internal&quot;</span>);</div><div class="line"><span class="comment">// Now, the clock source is definitely set to &quot;internal&quot;!</span></div><div class="line"><span class="comment">// The next call probably won&#39;t do anything but will return immediately,</span></div><div class="line"><span class="comment">// because the clock source was already set to &quot;internal&quot;</span></div><div class="line">usrp-&gt;set_clock_source(<span class="stringliteral">&quot;internal&quot;</span>);</div><div class="line"><span class="comment">// The clock source is still guaranteed to be &quot;internal&quot; at this point</span></div></div><!-- fragment --><p>See also:</p><ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac840a47c402b60b3a5d7fd6aac914300">set_sync_source()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the time source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1value__error.html">uhd::value_error</a></td><td>if <code>source</code> is an invalid option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60445c1a52e4763b6ebbbfce2db96569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60445c1a52e4763b6ebbbfce2db96569">&#9670;&nbsp;</a></span>set_clock_source_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_source_out </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send the clock source to an output connector. This call is only applicable on devices with reference outputs. By default, the reference output will be enabled for ease of use. This call may be used to enable or disable the output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to output the clock source. </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a191b78b00d051d3d51c2f719361c1fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191b78b00d051d3d51c2f719361c1fb5">&#9670;&nbsp;</a></span>set_command_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_command_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time at which the control commands will take effect.</p>
<p>A timed command will back-pressure all subsequent timed commands, assuming that the subsequent commands occur within the time-window. If the time spec is late, the command will be activated upon arrival.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time at which the next command will activate </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a560768e388cd6494320b72fe9536b0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560768e388cd6494320b72fe9536b0ee">&#9670;&nbsp;</a></span>set_filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write back a filter obtained by <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab058a3c56d12404c962c4399ecb3ed22">get_filter()</a> to the signal path. This filter can be a modified version of the originally returned one. The information about Rx or Tx is contained in the path parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the name of the filter as returned from <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names()</a>. </td></tr>
    <tr><td class="paramname">filter</td><td>the <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> of the filter object to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f25d118d20311aca261e6dd252625e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f25d118d20311aca261e6dd252625e">&#9670;&nbsp;</a></span>set_gpio_attr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_gpio_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>CTRL - 1 for ATR mode 0 for GPIO mode</li>
<li>DDR - 1 for output 0 for input</li>
<li>OUT - GPIO output level (not ATR mode)</li>
<li>ATR_0X - ATR idle state</li>
<li>ATR_RX - ATR receive only state</li>
<li>ATR_TX - ATR transmit only state</li>
<li>ATR_XX - ATR full duplex state <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">value</td><td>the new value for this GPIO bank </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask to effect which pins are changed </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a93eee2ffaf6f96b4c9abb3740614c40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93eee2ffaf6f96b4c9abb3740614c40b">&#9670;&nbsp;</a></span>set_gpio_attr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_gpio_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>SRC - "PS" for handling by processing system<ul>
<li>"RADIO_N/M" for handling by radio block with N is in [0..Number of Radio]; M is in [0..Number of port per Radio]</li>
</ul>
</li>
<li>CTRL - "ATR" for ATR mode<ul>
<li>"GPIO" for GPIO mode</li>
</ul>
</li>
<li>DDR - "OUT" for output<ul>
<li>"IN" for input</li>
</ul>
</li>
<li>OUT - a string of numbers representing GPIO output level (not ATR mode)<ul>
<li>"HIGH"or "LOW" as GPIO output level that apply for each bit mask that is 1</li>
</ul>
</li>
<li>ATR_0X - a string of numbers representing a value of the ATR idle state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR idle state register</li>
</ul>
</li>
<li>ATR_RX - a string of numbers representing a value of a ATR receive only state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR receive only state register</li>
</ul>
</li>
<li>ATR_TX - a string of numbers representing a value of the ATR transmit only state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR transmit only state register</li>
</ul>
</li>
<li>ATR_XX - a string of numbers representing a value of the ATR full duplex state register<ul>
<li>"HIGH" or "LOW" as a value set on each bit on of the ATR full duplex state register <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">value</td><td>the new value for this GPIO bank </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask to effect which pins are changed </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a99254abfa5259b70a020e667eee619b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99254abfa5259b70a020e667eee619b9">&#9670;&nbsp;</a></span>set_master_clock_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the master clock rate.</p>
<p>What exactly this changes is device-dependent, but it will always affect the rate at which the ADC/DAC is running.</p>
<p>Like tuning receive or transmit frequencies, this call will do a best effort to change the master clock rate. The device will coerce to the closest clock rate available, and on many devices won't actually change anything at all. Call <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate()</a> to see which rate was actually applied.</p>
<p>Note that changing this value during streaming is not recommended and can have random side effects.</p>
<p>If the device has an 'auto clock rate' setting (e.g. B200, see also <a class="el" href="page_usrp_b200.html#b200_auto_mcr">Automatic Clock Rate Setting</a>), calling this function will disable the automatic clock rate selection, and the clock rate will be fixed to <code>rate</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the new master clock rate in Hz </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab695b20f1053663669d45669af60f834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab695b20f1053663669d45669af60f834">&#9670;&nbsp;</a></span>set_normalized_rx_gain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_normalized_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the normalized RX gain value.</p>
<p>The normalized gain is a value in [0, 1], where 0 is the smallest gain value available, and 1 is the largest, independent of the device. In between, gains are linearly interpolated.</p>
<p>Check the individual device manual for notes on the gain range.</p>
<p>Note that it is not possible to specify a gain name for this function, it will always set the overall gain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the normalized gain value </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0fed2c1b4f34b7c84eb6bb51d189e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fed2c1b4f34b7c84eb6bb51d189e7e">&#9670;&nbsp;</a></span>set_normalized_tx_gain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_normalized_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the normalized TX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion on normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the normalized gain value </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdab1f6c3775a9071b15c9805f866486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdab1f6c3775a9071b15c9805f866486">&#9670;&nbsp;</a></span>set_rx_agc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_agc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable or disable the RX AGC module. Once this module is enabled manual gain settings will be ignored. The AGC will start in a default configuration which should be good for most use cases. Device specific configuration parameters can be found in the property tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable or Disable the AGC </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b7947cb0c434b98e9915f91b8f8fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b7947cb0c434b98e9915f91b8f8fe0">&#9670;&nbsp;</a></span>set_rx_antenna()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the RX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e026819f286e69c48c2e1956d95c6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e026819f286e69c48c2e1956d95c6fb">&#9670;&nbsp;</a></span>set_rx_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7beb49c1a04a81b3e7569db482453746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beb49c1a04a81b3e7569db482453746">&#9670;&nbsp;</a></span>set_rx_dc_offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable/disable the automatic RX DC offset correction. The automatic correction subtracts out the long-run average.</p>
<p>When disabled, the averaging option operation is halted. Once halted, the average value will be held constant until the user re-enables the automatic correction or overrides the value by manually setting the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to enable automatic DC offset correction </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8212c1131a34823430c9bdec9c183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8212c1131a34823430c9bdec9c183f">&#9670;&nbsp;</a></span>set_rx_dc_offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a constant RX DC offset value. The value is complex to control both I and Q. Only set this when automatic correction is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b61448f392466e20572fdcb042e8ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b61448f392466e20572fdcb042e8ec6">&#9670;&nbsp;</a></span>set_rx_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_rx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tune result object </dd></dl>

</div>
</div>
<a id="ad602e7681b796deddd9231f022ffef11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad602e7681b796deddd9231f022ffef11">&#9670;&nbsp;</a></span>set_rx_gain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8234968ad1fefef299ef9541cc193915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8234968ad1fefef299ef9541cc193915">&#9670;&nbsp;</a></span>set_rx_gain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for setting overall RX gain. </p>

</div>
</div>
<a id="a30a73d69712d79f6dbeff970f93153e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a73d69712d79f6dbeff970f93153e9">&#9670;&nbsp;</a></span>set_rx_gain_profile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_gain_profile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX gain profile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td>the profile string option </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586c52db545664cb2caf830ac90c051e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586c52db545664cb2caf830ac90c051e">&#9670;&nbsp;</a></span>set_rx_iq_balance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable/disable the automatic IQ imbalance correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to enable automatic IQ balance correction </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ccd212322a5da010ba79f9f18561156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccd212322a5da010ba79f9f18561156">&#9670;&nbsp;</a></span>set_rx_iq_balance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5c1501c36151e4491b014fed8e7bcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c1501c36151e4491b014fed8e7bcda">&#9670;&nbsp;</a></span>set_rx_lo_export_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the LO used by the device is exported</p>
<p>For USRPs that support exportable LOs, this function configures if the LO used by chan is exported or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>if true then export the LO </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 for the source channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a></td><td>if LO exporting is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b6a2bf7136c0f43b6dcdc51afacbcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6a2bf7136c0f43b6dcdc51afacbcb5">&#9670;&nbsp;</a></span>set_rx_lo_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::set_rx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX LO frequency (Advanced).</p>
<p>The actual behaviour is device-specific. However, as a rule of thumb, this will coerce the underlying driver into some state. Typical situations include:</p><ul>
<li>LOs are internal, and this function is called to pin an LO to a certain value. This can force the driver to pick different IFs for different stages, and there may be situations where this behaviour can be used to reduce spurs in specific bands.</li>
<li>LOs are external. In this case, this function is used to notify UHD what the actual value of an externally provided LO is. The only time when calling this function is necessary is when the LO source is set to external, but the external LO can't be tuned to the exact value required by UHD to achieve a certain center frequency. In this case, calling <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b6a2bf7136c0f43b6dcdc51afacbcb5">set_rx_lo_freq()</a> will let UHD know that the LO is not the expected value, and it's possible that UHD will find other ways to compensate for the LO offset.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>the frequency to set the LO to </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a coerced LO frequency </dd></dl>

</div>
</div>
<a id="a865f1e3d08802842a73e1f0571110335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865f1e3d08802842a73e1f0571110335">&#9670;&nbsp;</a></span>set_rx_lo_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the LO source for the USRP device.</p>
<p>For USRPs that support selectable LO sources, this function allows switching between them. Typical options for source: internal, external.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>a string representing the LO source </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update. If the wildcard value ALL_LOS is used, the setting will be applied to all LOs on this channel. </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a587cfb5be38a16fec532793b34fbf947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587cfb5be38a16fec532793b34fbf947">&#9670;&nbsp;</a></span>set_rx_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f94ed00059cc7dd30567d031b3f9679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f94ed00059cc7dd30567d031b3f9679">&#9670;&nbsp;</a></span>set_rx_subdev_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac840a47c402b60b3a5d7fd6aac914300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac840a47c402b60b3a5d7fd6aac914300">&#9670;&nbsp;</a></span>set_sync_source() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_sync_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>clock_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>time_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the reference/synchronization sources for the USRP device</p>
<p>This is a shorthand for calling <code>set_sync_source(<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a>("clock_source=$CLOCK_SOURCE,time_source=$TIME_SOURCE"))</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_source</td><td>A string representing the clock source </td></tr>
    <tr><td class="paramname">time_source</td><td>A string representing the time source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1value__error.html">uhd::value_error</a></td><td>if the sources don't actually exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b94b74c112f76c5b0c1e9e3e77124ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b94b74c112f76c5b0c1e9e3e77124ce">&#9670;&nbsp;</a></span>set_sync_source() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_sync_source </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sync_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the reference/synchronization sources for the USRP device</p>
<p>Typically, this will set both clock and time source in a single call. For some USRPs, this may be significantly faster than calling <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source()</a> and <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source()</a> individually.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line">usrp-&gt;set_sync_source(</div><div class="line">    device_addr_t(<span class="stringliteral">&quot;clock_source=external,time_source=external&quot;</span>));</div></div><!-- fragment --><p>This function does not force a re-initialization of the underlying hardware when the value does not change. See also <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source()</a> and <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync_source</td><td>A dictionary representing the various source settings. </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1value__error.html">uhd::value_error</a></td><td>if the sources don't actually exist or if the combination of clock and time source is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b1c5375549e6a446d686ee7d9b4e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1c5375549e6a446d686ee7d9b4e14">&#9670;&nbsp;</a></span>set_time_next_pps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_next_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time registers on the usrp at the next pps tick. The values will not be latched in until the pulse occurs. It is recommended that the user sleep(1) after calling to ensure that the time registers will be in a known state prior to use.</p>
<p>Note: Because this call sets the time on the "next" pps, the seconds in the time spec should be current seconds + 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351a2c3081944a0d2caab95e2a2f0926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351a2c3081944a0d2caab95e2a2f0926">&#9670;&nbsp;</a></span>set_time_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_now </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the time registers on the usrp immediately.</p>
<p>If only one MIMO master is present in your configuration, set_time_now is safe to use because the slave's time automatically follows the master's time. Otherwise, this call cannot set the time synchronously across multiple devices. Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a5580ba06d7d6a037c9ef64f1ea361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a5580ba06d7d6a037c9ef64f1ea361">&#9670;&nbsp;</a></span>set_time_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time source for the USRP device</p>
<p>This sets the method of time synchronization, typically a pulse per second signal. In order to time-align multiple USRPs, it is necessary to connect all of them to a common reference and provide them with the same time source. Typical values for <code>source</code> are 'internal', 'external'. Refer to the specific device manual for a full list of options.</p>
<p>If the value for for <code>source</code> is not available for this device, it will throw an exception. Calling <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aee040da1b7ae375e0c08bb0b080d7ccc">get_time_sources()</a> will return a valid list of options for this method.</p>
<p>Side effects: Some devices only support certain combinations of time and clock source. It is possible that the underlying device implementation will change the clock source when the time source changes and vice versa. Reading back the current values of clock and time source using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">get_clock_source()</a> and <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">get_time_source()</a> is the only certain way of knowing which clock and time source are currently selected.</p>
<p>This function does not force a re-initialization of the underlying hardware when the value does not change. Consider the following snippet: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(device_args);</div><div class="line"><span class="comment">// This may or may not cause the hardware to reconfigure, depending on</span></div><div class="line"><span class="comment">// the default state of the device</span></div><div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;internal&quot;</span>);</div><div class="line"><span class="comment">// Now, the time source is definitely set to &quot;internal&quot;!</span></div><div class="line"><span class="comment">// The next call probably won&#39;t do anything but will return immediately,</span></div><div class="line"><span class="comment">// because the time source was already set to &quot;internal&quot;</span></div><div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;internal&quot;</span>);</div><div class="line"><span class="comment">// The time source is still guaranteed to be &quot;internal&quot; at this point</span></div></div><!-- fragment --><p>See also:</p><ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac840a47c402b60b3a5d7fd6aac914300">set_sync_source()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the time source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1value__error.html">uhd::value_error</a></td><td>if <code>source</code> is an invalid option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a1a4bf21fb32bf761204ce0561b5aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1a4bf21fb32bf761204ce0561b5aa7">&#9670;&nbsp;</a></span>set_time_source_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_source_out </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send the time source to an output connector. This call is only applicable on devices with PPS outputs. By default, the PPS output will be enabled for ease of use. This call may be used to enable or disable the output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to output the time source. </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a413014bf3aea4a8ea2d268b4a3b390e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413014bf3aea4a8ea2d268b4a3b390e9">&#9670;&nbsp;</a></span>set_time_unknown_pps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_unknown_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronize the times across all motherboards in this configuration. Use this method to sync the times when the edge of the PPS is unknown.</p>
<p>Ex: Host machine is not attached to serial port of GPSDO and can therefore not query the GPSDO for the PPS edge.</p>
<p>This is a 2-step process, and will take at most 2 seconds to complete. Upon completion, the times will be synchronized to the time provided.</p>
<ul>
<li>Step1: wait for the last pps time to transition to catch the edge</li>
<li>Step2: set the time at the next pps (synchronous for all boards)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch at the next pps after catching the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e8cd16aa93bf3375cdcd3daca3b6b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8cd16aa93bf3375cdcd3daca3b6b24">&#9670;&nbsp;</a></span>set_tx_antenna()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the TX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04bfc300735435a7937d4eb37e5523d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04bfc300735435a7937d4eb37e5523d">&#9670;&nbsp;</a></span>set_tx_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a263ab7f0364c03e8a6e330c546769e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263ab7f0364c03e8a6e330c546769e4f">&#9670;&nbsp;</a></span>set_tx_dc_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a constant TX DC offset value. The value is complex to control both I and Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7a674a9d012a78dd4f2ded478839124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a674a9d012a78dd4f2ded478839124">&#9670;&nbsp;</a></span>set_tx_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_tx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tune result object </dd></dl>

</div>
</div>
<a id="a41cc3c774451d0a2c5f69cd8df0f9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cc3c774451d0a2c5f69cd8df0f9f06">&#9670;&nbsp;</a></span>set_tx_gain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1101dc00b016fe91a299cbcae8b12053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1101dc00b016fe91a299cbcae8b12053">&#9670;&nbsp;</a></span>set_tx_gain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for setting overall TX gain. </p>

</div>
</div>
<a id="a7fd5ad4102937546593c579157e2be1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd5ad4102937546593c579157e2be1d">&#9670;&nbsp;</a></span>set_tx_gain_profile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_gain_profile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>profile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX gain profile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td>the profile string option </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad938e609a11773e21611ee86a0e1b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad938e609a11773e21611ee86a0e1b1c5">&#9670;&nbsp;</a></span>set_tx_iq_balance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e1c9dfa06995d9ec5f3450c42007381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1c9dfa06995d9ec5f3450c42007381">&#9670;&nbsp;</a></span>set_tx_lo_export_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the TX LO used by the device is exported</p>
<p>For USRPs that support exportable LOs, this function configures if the LO used by chan is exported or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>if true then export the LO </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 for the source channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a></td><td>if LO exporting is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e0203de8957159b66fa34c4f61f819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0203de8957159b66fa34c4f61f819c">&#9670;&nbsp;</a></span>set_tx_lo_freq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::set_tx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX LO frequency (Advanced).</p>
<p>The actual behaviour is device-specific. However, as a rule of thumb, this will coerce the underlying driver into some state. Typical situations include:</p><ul>
<li>LOs are internal, and this function is called to pin an LO to a certain value. This can force the driver to pick different IFs for different stages, and there may be situations where this behaviour can be used to reduce spurs in specific bands.</li>
<li>LOs are external. In this case, this function is used to notify UHD what the actual value of an externally provided LO is. The only time when calling this function is necessary is when the LO source is set to external, but the external LO can't be tuned to the exact value required by UHD to achieve a certain center frequency. In this case, calling <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6e0203de8957159b66fa34c4f61f819c">set_tx_lo_freq()</a> will let UHD know that the LO is not the expected value, and it's possible that UHD will find other ways to compensate for the LO offset.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>the frequency to set the LO to </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a coerced LO frequency </dd></dl>

</div>
</div>
<a id="afa6d2c73c531cee18ea6490fa19cfc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6d2c73c531cee18ea6490fa19cfc92">&#9670;&nbsp;</a></span>set_tx_lo_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX LO source for the USRP device.</p>
<p>For USRPs that support selectable LO sources, this function allows switching between them. Typical options for source: internal, external.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>a string representing the LO source </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update. If the wildcard value ALL_LOS is used, the setting will be applied to all LOs on this channel. </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8bc17744d3ee94b7c5cdcb75457bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bc17744d3ee94b7c5cdcb75457bd6b">&#9670;&nbsp;</a></span>set_tx_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b8d9d9fb9a1ec51e81a207cd299e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8d9d9fb9a1ec51e81a207cd299e517">&#9670;&nbsp;</a></span>set_tx_subdev_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a417d8733daa8582957e8de4741ef9ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417d8733daa8582957e8de4741ef9ced">&#9670;&nbsp;</a></span>set_user_register()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_user_register </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform write on the user configuration register bus. These only exist if the user has implemented custom setting registers in the device FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>8-bit register address </td></tr>
    <tr><td class="paramname">data</td><td>32-bit register value </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the user register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0b729c61604ec4569e1e97b6240ec71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b729c61604ec4569e1e97b6240ec71">&#9670;&nbsp;</a></span>write_register()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::write_register </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a low-level register field for a register in the USRP hardware </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">field</td><td>the identifier of bitfield to be written (all other bits remain unchanged) </td></tr>
    <tr><td class="paramname">value</td><td>the value to write to the register field </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afeaca319029cb49f7041461345ab641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaca319029cb49f7041461345ab641c">&#9670;&nbsp;</a></span>ALL_CHANS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t uhd::usrp::multi_usrp::ALL_CHANS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard channel index. </p>

</div>
</div>
<a id="a524b7e2177492e59382f1124ee32c12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524b7e2177492e59382f1124ee32c12b">&#9670;&nbsp;</a></span>ALL_GAINS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string uhd::usrp::multi_usrp::ALL_GAINS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard gain element name. </p>

</div>
</div>
<a id="a1d5eaa4fb855a52aa97c328ec2fa387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5eaa4fb855a52aa97c328ec2fa387b">&#9670;&nbsp;</a></span>ALL_LOS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string uhd::usrp::multi_usrp::ALL_LOS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard LO stage name. </p>

</div>
</div>
<a id="a21f2ba01462e1f211a8823fda24a82d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f2ba01462e1f211a8823fda24a82d5">&#9670;&nbsp;</a></span>ALL_MBOARDS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t uhd::usrp::multi_usrp::ALL_MBOARDS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard motherboard index. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/uhd/usrp/<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceuhd.html">uhd</a></li><li class="navelem"><a class="el" href="namespaceuhd_1_1usrp.html">usrp</a></li><li class="navelem"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
